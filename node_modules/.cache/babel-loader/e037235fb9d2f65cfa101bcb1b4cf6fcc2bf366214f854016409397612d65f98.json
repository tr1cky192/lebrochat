{"ast":null,"code":"var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator$1 = undefined && undefined.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (g && (g = 0, op[0] && (_ = 0)), _) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __read$1 = undefined && undefined.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray$1 = undefined && undefined.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __values = undefined && undefined.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n/**\n * Heap\n * @type {Class}\n */\nvar HeapAsync = /** @class */function () {\n  /**\n   * Heap instance constructor.\n   * @param  {Function} compare Optional comparison function, defaults to Heap.minComparator<number>\n   */\n  function HeapAsync(compare) {\n    if (compare === void 0) {\n      compare = HeapAsync.minComparator;\n    }\n    var _this = this;\n    this.compare = compare;\n    this.heapArray = [];\n    this._limit = 0;\n    /**\n     * Alias of add\n     */\n    this.offer = this.add;\n    /**\n     * Alias of peek\n     */\n    this.element = this.peek;\n    /**\n     * Alias of pop\n     */\n    this.poll = this.pop;\n    /**\n     * Returns the inverse to the comparison function.\n     * @return {Number}\n     */\n    this._invertedCompare = function (a, b) {\n      return _this.compare(a, b).then(function (res) {\n        return -1 * res;\n      });\n    };\n  }\n  /*\n            Static methods\n   */\n  /**\n   * Gets children indices for given index.\n   * @param  {Number} idx     Parent index\n   * @return {Array(Number)}  Array of children indices\n   */\n  HeapAsync.getChildrenIndexOf = function (idx) {\n    return [idx * 2 + 1, idx * 2 + 2];\n  };\n  /**\n   * Gets parent index for given index.\n   * @param  {Number} idx  Children index\n   * @return {Number | undefined}      Parent index, -1 if idx is 0\n   */\n  HeapAsync.getParentIndexOf = function (idx) {\n    if (idx <= 0) {\n      return -1;\n    }\n    var whichChildren = idx % 2 ? 1 : 2;\n    return Math.floor((idx - whichChildren) / 2);\n  };\n  /**\n   * Gets sibling index for given index.\n   * @param  {Number} idx  Children index\n   * @return {Number | undefined}      Sibling index, -1 if idx is 0\n   */\n  HeapAsync.getSiblingIndexOf = function (idx) {\n    if (idx <= 0) {\n      return -1;\n    }\n    var whichChildren = idx % 2 ? 1 : -1;\n    return idx + whichChildren;\n  };\n  /**\n   * Min heap comparison function, default.\n   * @param  {any} a     First element\n   * @param  {any} b     Second element\n   * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n   */\n  HeapAsync.minComparator = function (a, b) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator$1(this, function (_a) {\n        if (a > b) {\n          return [2 /*return*/, 1];\n        } else if (a < b) {\n          return [2 /*return*/, -1];\n        } else {\n          return [2 /*return*/, 0];\n        }\n      });\n    });\n  };\n  /**\n   * Max heap comparison function.\n   * @param  {any} a     First element\n   * @param  {any} b     Second element\n   * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n   */\n  HeapAsync.maxComparator = function (a, b) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator$1(this, function (_a) {\n        if (b > a) {\n          return [2 /*return*/, 1];\n        } else if (b < a) {\n          return [2 /*return*/, -1];\n        } else {\n          return [2 /*return*/, 0];\n        }\n      });\n    });\n  };\n  /**\n   * Min number heap comparison function, default.\n   * @param  {Number} a     First element\n   * @param  {Number} b     Second element\n   * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n   */\n  HeapAsync.minComparatorNumber = function (a, b) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator$1(this, function (_a) {\n        return [2 /*return*/, a - b];\n      });\n    });\n  };\n  /**\n   * Max number heap comparison function.\n   * @param  {Number} a     First element\n   * @param  {Number} b     Second element\n   * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n   */\n  HeapAsync.maxComparatorNumber = function (a, b) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator$1(this, function (_a) {\n        return [2 /*return*/, b - a];\n      });\n    });\n  };\n  /**\n   * Default equality function.\n   * @param  {any} a    First element\n   * @param  {any} b    Second element\n   * @return {Boolean}  True if equal, false otherwise\n   */\n  HeapAsync.defaultIsEqual = function (a, b) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator$1(this, function (_a) {\n        return [2 /*return*/, a === b];\n      });\n    });\n  };\n  /**\n   * Prints a heap.\n   * @param  {HeapAsync} heap Heap to be printed\n   * @returns {String}\n   */\n  HeapAsync.print = function (heap) {\n    function deep(i) {\n      var pi = HeapAsync.getParentIndexOf(i);\n      return Math.floor(Math.log2(pi + 1));\n    }\n    function repeat(str, times) {\n      var out = '';\n      for (; times > 0; --times) {\n        out += str;\n      }\n      return out;\n    }\n    var node = 0;\n    var lines = [];\n    var maxLines = deep(heap.length - 1) + 2;\n    var maxLength = 0;\n    while (node < heap.length) {\n      var i = deep(node) + 1;\n      if (node === 0) {\n        i = 0;\n      }\n      // Text representation\n      var nodeText = String(heap.get(node));\n      if (nodeText.length > maxLength) {\n        maxLength = nodeText.length;\n      }\n      // Add to line\n      lines[i] = lines[i] || [];\n      lines[i].push(nodeText);\n      node += 1;\n    }\n    return lines.map(function (line, i) {\n      var times = Math.pow(2, maxLines - i) - 1;\n      return repeat(' ', Math.floor(times / 2) * maxLength) + line.map(function (el) {\n        // centered\n        var half = (maxLength - el.length) / 2;\n        return repeat(' ', Math.ceil(half)) + el + repeat(' ', Math.floor(half));\n      }).join(repeat(' ', times * maxLength));\n    }).join('\\n');\n  };\n  /*\n            Python style\n   */\n  /**\n   * Converts an array into an array-heap, in place\n   * @param  {Array}    arr      Array to be modified\n   * @param  {Function} compare  Optional compare function\n   * @return {HeapAsync}              For convenience, it returns a Heap instance\n   */\n  HeapAsync.heapify = function (arr, compare) {\n    return __awaiter(this, void 0, void 0, function () {\n      var heap;\n      return __generator$1(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            heap = new HeapAsync(compare);\n            heap.heapArray = arr;\n            return [4 /*yield*/, heap.init()];\n          case 1:\n            _a.sent();\n            return [2 /*return*/, heap];\n        }\n      });\n    });\n  };\n  /**\n   * Extract the peek of an array-heap\n   * @param  {Array}    heapArr  Array to be modified, should be a heap\n   * @param  {Function} compare  Optional compare function\n   * @return {any}               Returns the extracted peek\n   */\n  HeapAsync.heappop = function (heapArr, compare) {\n    var heap = new HeapAsync(compare);\n    heap.heapArray = heapArr;\n    return heap.pop();\n  };\n  /**\n   * Pushes a item into an array-heap\n   * @param  {Array}    heapArr  Array to be modified, should be a heap\n   * @param  {any}      item     Item to push\n   * @param  {Function} compare  Optional compare function\n   */\n  HeapAsync.heappush = function (heapArr, item, compare) {\n    return __awaiter(this, void 0, void 0, function () {\n      var heap;\n      return __generator$1(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            heap = new HeapAsync(compare);\n            heap.heapArray = heapArr;\n            return [4 /*yield*/, heap.push(item)];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Push followed by pop, faster\n   * @param  {Array}    heapArr  Array to be modified, should be a heap\n   * @param  {any}      item     Item to push\n   * @param  {Function} compare  Optional compare function\n   * @return {any}               Returns the extracted peek\n   */\n  HeapAsync.heappushpop = function (heapArr, item, compare) {\n    var heap = new HeapAsync(compare);\n    heap.heapArray = heapArr;\n    return heap.pushpop(item);\n  };\n  /**\n   * Replace peek with item\n   * @param  {Array}    heapArr  Array to be modified, should be a heap\n   * @param  {any}      item     Item as replacement\n   * @param  {Function} compare  Optional compare function\n   * @return {any}               Returns the extracted peek\n   */\n  HeapAsync.heapreplace = function (heapArr, item, compare) {\n    var heap = new HeapAsync(compare);\n    heap.heapArray = heapArr;\n    return heap.replace(item);\n  };\n  /**\n   * Return the `n` most valuable elements of a heap-like Array\n   * @param  {Array}    heapArr  Array, should be an array-heap\n   * @param  {number}   n        Max number of elements\n   * @param  {Function} compare  Optional compare function\n   * @return {any}               Elements\n   */\n  HeapAsync.heaptop = function (heapArr, n, compare) {\n    if (n === void 0) {\n      n = 1;\n    }\n    var heap = new HeapAsync(compare);\n    heap.heapArray = heapArr;\n    return heap.top(n);\n  };\n  /**\n   * Return the `n` least valuable elements of a heap-like Array\n   * @param  {Array}    heapArr  Array, should be an array-heap\n   * @param  {number}   n        Max number of elements\n   * @param  {Function} compare  Optional compare function\n   * @return {any}               Elements\n   */\n  HeapAsync.heapbottom = function (heapArr, n, compare) {\n    if (n === void 0) {\n      n = 1;\n    }\n    var heap = new HeapAsync(compare);\n    heap.heapArray = heapArr;\n    return heap.bottom(n);\n  };\n  /**\n   * Return the `n` most valuable elements of an iterable\n   * @param  {number}   n        Max number of elements\n   * @param  {Iterable} Iterable Iterable list of elements\n   * @param  {Function} compare  Optional compare function\n   * @return {any}               Elements\n   */\n  HeapAsync.nlargest = function (n, iterable, compare) {\n    return __awaiter(this, void 0, void 0, function () {\n      var heap;\n      return __generator$1(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            heap = new HeapAsync(compare);\n            heap.heapArray = __spreadArray$1([], __read$1(iterable), false);\n            return [4 /*yield*/, heap.init()];\n          case 1:\n            _a.sent();\n            return [2 /*return*/, heap.top(n)];\n        }\n      });\n    });\n  };\n  /**\n   * Return the `n` least valuable elements of an iterable\n   * @param  {number}   n        Max number of elements\n   * @param  {Iterable} Iterable Iterable list of elements\n   * @param  {Function} compare  Optional compare function\n   * @return {any}               Elements\n   */\n  HeapAsync.nsmallest = function (n, iterable, compare) {\n    return __awaiter(this, void 0, void 0, function () {\n      var heap;\n      return __generator$1(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            heap = new HeapAsync(compare);\n            heap.heapArray = __spreadArray$1([], __read$1(iterable), false);\n            return [4 /*yield*/, heap.init()];\n          case 1:\n            _a.sent();\n            return [2 /*return*/, heap.bottom(n)];\n        }\n      });\n    });\n  };\n  /*\n            Instance methods\n   */\n  /**\n   * Adds an element to the heap. Aliases: `offer`.\n   * Same as: push(element)\n   * @param {any} element Element to be added\n   * @return {Boolean} true\n   */\n  HeapAsync.prototype.add = function (element) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator$1(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this._sortNodeUp(this.heapArray.push(element) - 1)];\n          case 1:\n            _a.sent();\n            this._applyLimit();\n            return [2 /*return*/, true];\n        }\n      });\n    });\n  };\n  /**\n   * Adds an array of elements to the heap.\n   * Similar as: push(element, element, ...).\n   * @param {Array} elements Elements to be added\n   * @return {Boolean} true\n   */\n  HeapAsync.prototype.addAll = function (elements) {\n    return __awaiter(this, void 0, void 0, function () {\n      var i, l;\n      var _a;\n      return __generator$1(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            i = this.length;\n            (_a = this.heapArray).push.apply(_a, __spreadArray$1([], __read$1(elements), false));\n            l = this.length;\n            _b.label = 1;\n          case 1:\n            if (!(i < l)) return [3 /*break*/, 4];\n            return [4 /*yield*/, this._sortNodeUp(i)];\n          case 2:\n            _b.sent();\n            _b.label = 3;\n          case 3:\n            ++i;\n            return [3 /*break*/, 1];\n          case 4:\n            this._applyLimit();\n            return [2 /*return*/, true];\n        }\n      });\n    });\n  };\n  /**\n   * Return the bottom (lowest value) N elements of the heap.\n   *\n   * @param  {Number} n  Number of elements.\n   * @return {Array}     Array of length <= N.\n   */\n  HeapAsync.prototype.bottom = function (n) {\n    if (n === void 0) {\n      n = 1;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator$1(this, function (_a) {\n        if (this.heapArray.length === 0 || n <= 0) {\n          // Nothing to do\n          return [2 /*return*/, []];\n        } else if (this.heapArray.length === 1) {\n          // Just the peek\n          return [2 /*return*/, [this.heapArray[0]]];\n        } else if (n >= this.heapArray.length) {\n          // The whole heap\n          return [2 /*return*/, __spreadArray$1([], __read$1(this.heapArray), false)];\n        } else {\n          // Some elements\n          return [2 /*return*/, this._bottomN_push(~~n)];\n        }\n      });\n    });\n  };\n  /**\n   * Check if the heap is sorted, useful for testing purposes.\n   * @return {Undefined | Element}  Returns an element if something wrong is found, otherwise it's undefined\n   */\n  HeapAsync.prototype.check = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var j, el, children, children_1, children_1_1, ch, e_1_1;\n      var e_1, _a;\n      return __generator$1(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            j = 0;\n            _b.label = 1;\n          case 1:\n            if (!(j < this.heapArray.length)) return [3 /*break*/, 10];\n            el = this.heapArray[j];\n            children = this.getChildrenOf(j);\n            _b.label = 2;\n          case 2:\n            _b.trys.push([2, 7, 8, 9]);\n            children_1 = (e_1 = void 0, __values(children)), children_1_1 = children_1.next();\n            _b.label = 3;\n          case 3:\n            if (!!children_1_1.done) return [3 /*break*/, 6];\n            ch = children_1_1.value;\n            return [4 /*yield*/, this.compare(el, ch)];\n          case 4:\n            if (_b.sent() > 0) {\n              return [2 /*return*/, el];\n            }\n            _b.label = 5;\n          case 5:\n            children_1_1 = children_1.next();\n            return [3 /*break*/, 3];\n          case 6:\n            return [3 /*break*/, 9];\n          case 7:\n            e_1_1 = _b.sent();\n            e_1 = {\n              error: e_1_1\n            };\n            return [3 /*break*/, 9];\n          case 8:\n            try {\n              if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n            return [7 /*endfinally*/];\n          case 9:\n            ++j;\n            return [3 /*break*/, 1];\n          case 10:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Remove all of the elements from this heap.\n   */\n  HeapAsync.prototype.clear = function () {\n    this.heapArray = [];\n  };\n  /**\n   * Clone this heap\n   * @return {HeapAsync}\n   */\n  HeapAsync.prototype.clone = function () {\n    var cloned = new HeapAsync(this.comparator());\n    cloned.heapArray = this.toArray();\n    cloned._limit = this._limit;\n    return cloned;\n  };\n  /**\n   * Returns the comparison function.\n   * @return {Function}\n   */\n  HeapAsync.prototype.comparator = function () {\n    return this.compare;\n  };\n  /**\n   * Returns true if this queue contains the specified element.\n   * @param  {any}      o   Element to be found\n   * @param  {Function} fn  Optional comparison function, receives (element, needle)\n   * @return {Boolean}\n   */\n  HeapAsync.prototype.contains = function (o, fn) {\n    if (fn === void 0) {\n      fn = HeapAsync.defaultIsEqual;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, _b, el, e_2_1;\n      var e_2, _c;\n      return __generator$1(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            _d.trys.push([0, 5, 6, 7]);\n            _a = __values(this.heapArray), _b = _a.next();\n            _d.label = 1;\n          case 1:\n            if (!!_b.done) return [3 /*break*/, 4];\n            el = _b.value;\n            return [4 /*yield*/, fn(el, o)];\n          case 2:\n            if (_d.sent()) {\n              return [2 /*return*/, true];\n            }\n            _d.label = 3;\n          case 3:\n            _b = _a.next();\n            return [3 /*break*/, 1];\n          case 4:\n            return [3 /*break*/, 7];\n          case 5:\n            e_2_1 = _d.sent();\n            e_2 = {\n              error: e_2_1\n            };\n            return [3 /*break*/, 7];\n          case 6:\n            try {\n              if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n            return [7 /*endfinally*/];\n          case 7:\n            return [2 /*return*/, false];\n        }\n      });\n    });\n  };\n  /**\n   * Initialise a heap, sorting nodes\n   * @param  {Array} array Optional initial state array\n   */\n  HeapAsync.prototype.init = function (array) {\n    return __awaiter(this, void 0, void 0, function () {\n      var i;\n      return __generator$1(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (array) {\n              this.heapArray = __spreadArray$1([], __read$1(array), false);\n            }\n            i = Math.floor(this.heapArray.length);\n            _a.label = 1;\n          case 1:\n            if (!(i >= 0)) return [3 /*break*/, 4];\n            return [4 /*yield*/, this._sortNodeDown(i)];\n          case 2:\n            _a.sent();\n            _a.label = 3;\n          case 3:\n            --i;\n            return [3 /*break*/, 1];\n          case 4:\n            this._applyLimit();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Test if the heap has no elements.\n   * @return {Boolean} True if no elements on the heap\n   */\n  HeapAsync.prototype.isEmpty = function () {\n    return this.length === 0;\n  };\n  /**\n   * Get the leafs of the tree (no children nodes)\n   */\n  HeapAsync.prototype.leafs = function () {\n    if (this.heapArray.length === 0) {\n      return [];\n    }\n    var pi = HeapAsync.getParentIndexOf(this.heapArray.length - 1);\n    return this.heapArray.slice(pi + 1);\n  };\n  Object.defineProperty(HeapAsync.prototype, \"length\", {\n    /**\n     * Length of the heap.\n     * @return {Number}\n     */\n    get: function () {\n      return this.heapArray.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(HeapAsync.prototype, \"limit\", {\n    /**\n     * Get length limit of the heap.\n     * @return {Number}\n     */\n    get: function () {\n      return this._limit;\n    },\n    /**\n     * Set length limit of the heap.\n     * @return {Number}\n     */\n    set: function (_l) {\n      this._limit = ~~_l;\n      this._applyLimit();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Top node. Aliases: `element`.\n   * Same as: `top(1)[0]`\n   * @return {any} Top node\n   */\n  HeapAsync.prototype.peek = function () {\n    return this.heapArray[0];\n  };\n  /**\n   * Extract the top node (root). Aliases: `poll`.\n   * @return {any} Extracted top node, undefined if empty\n   */\n  HeapAsync.prototype.pop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var last;\n      return __generator$1(this, function (_a) {\n        last = this.heapArray.pop();\n        if (this.length > 0 && last !== undefined) {\n          return [2 /*return*/, this.replace(last)];\n        }\n        return [2 /*return*/, last];\n      });\n    });\n  };\n  /**\n   * Pushes element(s) to the heap.\n   * @param  {...any} elements Elements to insert\n   * @return {Boolean} True if elements are present\n   */\n  HeapAsync.prototype.push = function () {\n    var elements = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      elements[_i] = arguments[_i];\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator$1(this, function (_a) {\n        if (elements.length < 1) {\n          return [2 /*return*/, false];\n        } else if (elements.length === 1) {\n          return [2 /*return*/, this.add(elements[0])];\n        } else {\n          return [2 /*return*/, this.addAll(elements)];\n        }\n      });\n    });\n  };\n  /**\n   * Same as push & pop in sequence, but faster\n   * @param  {any} element Element to insert\n   * @return {any}  Extracted top node\n   */\n  HeapAsync.prototype.pushpop = function (element) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n      return __generator$1(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.compare(this.heapArray[0], element)];\n          case 1:\n            if (!(_b.sent() < 0)) return [3 /*break*/, 3];\n            _a = __read$1([this.heapArray[0], element], 2), element = _a[0], this.heapArray[0] = _a[1];\n            return [4 /*yield*/, this._sortNodeDown(0)];\n          case 2:\n            _b.sent();\n            _b.label = 3;\n          case 3:\n            return [2 /*return*/, element];\n        }\n      });\n    });\n  };\n  /**\n   * Remove an element from the heap.\n   * @param  {any}   o      Element to be found\n   * @param  {Function} fn  Optional function to compare\n   * @return {Boolean}      True if the heap was modified\n   */\n  HeapAsync.prototype.remove = function (o, fn) {\n    if (fn === void 0) {\n      fn = HeapAsync.defaultIsEqual;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var idx, i;\n      return __generator$1(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(this.length > 0)) return [3 /*break*/, 13];\n            if (!(o === undefined)) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.pop()];\n          case 1:\n            _a.sent();\n            return [2 /*return*/, true];\n          case 2:\n            idx = -1;\n            i = 0;\n            _a.label = 3;\n          case 3:\n            if (!(i < this.heapArray.length)) return [3 /*break*/, 6];\n            return [4 /*yield*/, fn(this.heapArray[i], o)];\n          case 4:\n            if (_a.sent()) {\n              idx = i;\n              return [3 /*break*/, 6];\n            }\n            _a.label = 5;\n          case 5:\n            ++i;\n            return [3 /*break*/, 3];\n          case 6:\n            if (!(idx >= 0)) return [3 /*break*/, 13];\n            if (!(idx === 0)) return [3 /*break*/, 8];\n            return [4 /*yield*/, this.pop()];\n          case 7:\n            _a.sent();\n            return [3 /*break*/, 12];\n          case 8:\n            if (!(idx === this.length - 1)) return [3 /*break*/, 9];\n            this.heapArray.pop();\n            return [3 /*break*/, 12];\n          case 9:\n            this.heapArray.splice(idx, 1, this.heapArray.pop());\n            return [4 /*yield*/, this._sortNodeUp(idx)];\n          case 10:\n            _a.sent();\n            return [4 /*yield*/, this._sortNodeDown(idx)];\n          case 11:\n            _a.sent();\n            _a.label = 12;\n          case 12:\n            return [2 /*return*/, true];\n          case 13:\n            return [2 /*return*/, false];\n        }\n      });\n    });\n  };\n  /**\n   * Pop the current peek value, and add the new item.\n   * @param  {any} element  Element to replace peek\n   * @return {any}         Old peek\n   */\n  HeapAsync.prototype.replace = function (element) {\n    return __awaiter(this, void 0, void 0, function () {\n      var peek;\n      return __generator$1(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            peek = this.heapArray[0];\n            this.heapArray[0] = element;\n            return [4 /*yield*/, this._sortNodeDown(0)];\n          case 1:\n            _a.sent();\n            return [2 /*return*/, peek];\n        }\n      });\n    });\n  };\n  /**\n   * Size of the heap\n   * @return {Number}\n   */\n  HeapAsync.prototype.size = function () {\n    return this.length;\n  };\n  /**\n   * Return the top (highest value) N elements of the heap.\n   *\n   * @param  {Number} n  Number of elements.\n   * @return {Array}    Array of length <= N.\n   */\n  HeapAsync.prototype.top = function (n) {\n    if (n === void 0) {\n      n = 1;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator$1(this, function (_a) {\n        if (this.heapArray.length === 0 || n <= 0) {\n          // Nothing to do\n          return [2 /*return*/, []];\n        } else if (this.heapArray.length === 1 || n === 1) {\n          // Just the peek\n          return [2 /*return*/, [this.heapArray[0]]];\n        } else if (n >= this.heapArray.length) {\n          // The whole peek\n          return [2 /*return*/, __spreadArray$1([], __read$1(this.heapArray), false)];\n        } else {\n          // Some elements\n          return [2 /*return*/, this._topN_push(~~n)];\n        }\n      });\n    });\n  };\n  /**\n   * Clone the heap's internal array\n   * @return {Array}\n   */\n  HeapAsync.prototype.toArray = function () {\n    return __spreadArray$1([], __read$1(this.heapArray), false);\n  };\n  /**\n   * String output, call to Array.prototype.toString()\n   * @return {String}\n   */\n  HeapAsync.prototype.toString = function () {\n    return this.heapArray.toString();\n  };\n  /**\n   * Get the element at the given index.\n   * @param  {Number} i Index to get\n   * @return {any}       Element at that index\n   */\n  HeapAsync.prototype.get = function (i) {\n    return this.heapArray[i];\n  };\n  /**\n   * Get the elements of these node's children\n   * @param  {Number} idx Node index\n   * @return {Array(any)}  Children elements\n   */\n  HeapAsync.prototype.getChildrenOf = function (idx) {\n    var _this = this;\n    return HeapAsync.getChildrenIndexOf(idx).map(function (i) {\n      return _this.heapArray[i];\n    }).filter(function (e) {\n      return e !== undefined;\n    });\n  };\n  /**\n   * Get the element of this node's parent\n   * @param  {Number} idx Node index\n   * @return {any}     Parent element\n   */\n  HeapAsync.prototype.getParentOf = function (idx) {\n    var pi = HeapAsync.getParentIndexOf(idx);\n    return this.heapArray[pi];\n  };\n  /**\n   * Iterator interface\n   */\n  HeapAsync.prototype[Symbol.iterator] = function () {\n    return __generator$1(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!this.length) return [3 /*break*/, 2];\n          return [4 /*yield*/, this.pop()];\n        case 1:\n          _a.sent();\n          return [3 /*break*/, 0];\n        case 2:\n          return [2 /*return*/];\n      }\n    });\n  };\n  /**\n   * Returns an iterator. To comply with Java interface.\n   */\n  HeapAsync.prototype.iterator = function () {\n    return this;\n  };\n  /**\n   * Limit heap size if needed\n   */\n  HeapAsync.prototype._applyLimit = function () {\n    if (this._limit && this._limit < this.heapArray.length) {\n      var rm = this.heapArray.length - this._limit;\n      // It's much faster than splice\n      while (rm) {\n        this.heapArray.pop();\n        --rm;\n      }\n    }\n  };\n  /**\n   * Return the bottom (lowest value) N elements of the heap, without corner cases, unsorted\n   *\n   * @param  {Number} n  Number of elements.\n   * @return {Array}     Array of length <= N.\n   */\n  HeapAsync.prototype._bottomN_push = function (n) {\n    return __awaiter(this, void 0, void 0, function () {\n      var bottomHeap, startAt, parentStartAt, indices, i, arr, i;\n      return __generator$1(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            bottomHeap = new HeapAsync(this.compare);\n            bottomHeap.limit = n;\n            bottomHeap.heapArray = this.heapArray.slice(-n);\n            return [4 /*yield*/, bottomHeap.init()];\n          case 1:\n            _a.sent();\n            startAt = this.heapArray.length - 1 - n;\n            parentStartAt = HeapAsync.getParentIndexOf(startAt);\n            indices = [];\n            for (i = startAt; i > parentStartAt; --i) {\n              indices.push(i);\n            }\n            arr = this.heapArray;\n            _a.label = 2;\n          case 2:\n            if (!indices.length) return [3 /*break*/, 6];\n            i = indices.shift();\n            return [4 /*yield*/, this.compare(arr[i], bottomHeap.peek())];\n          case 3:\n            if (!(_a.sent() > 0)) return [3 /*break*/, 5];\n            return [4 /*yield*/, bottomHeap.replace(arr[i])];\n          case 4:\n            _a.sent();\n            if (i % 2) {\n              indices.push(HeapAsync.getParentIndexOf(i));\n            }\n            _a.label = 5;\n          case 5:\n            return [3 /*break*/, 2];\n          case 6:\n            return [2 /*return*/, bottomHeap.toArray()];\n        }\n      });\n    });\n  };\n  /**\n   * Move a node to a new index, switching places\n   * @param  {Number} j First node index\n   * @param  {Number} k Another node index\n   */\n  HeapAsync.prototype._moveNode = function (j, k) {\n    var _a;\n    _a = __read$1([this.heapArray[k], this.heapArray[j]], 2), this.heapArray[j] = _a[0], this.heapArray[k] = _a[1];\n  };\n  /**\n   * Move a node down the tree (to the leaves) to find a place where the heap is sorted.\n   * @param  {Number} i Index of the node\n   */\n  HeapAsync.prototype._sortNodeDown = function (i) {\n    return __awaiter(this, void 0, void 0, function () {\n      var moveIt, self, getPotentialParent, childrenIdx, bestChildIndex, j, bestChild, _a;\n      var _this = this;\n      return __generator$1(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            moveIt = i < this.heapArray.length - 1;\n            self = this.heapArray[i];\n            getPotentialParent = function (best, j) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var _a;\n                return __generator$1(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      _a = this.heapArray.length > j;\n                      if (!_a) return [3 /*break*/, 2];\n                      return [4 /*yield*/, this.compare(this.heapArray[j], this.heapArray[best])];\n                    case 1:\n                      _a = _b.sent() < 0;\n                      _b.label = 2;\n                    case 2:\n                      if (_a) {\n                        best = j;\n                      }\n                      return [2 /*return*/, best];\n                  }\n                });\n              });\n            };\n            _b.label = 1;\n          case 1:\n            if (!moveIt) return [3 /*break*/, 8];\n            childrenIdx = HeapAsync.getChildrenIndexOf(i);\n            bestChildIndex = childrenIdx[0];\n            j = 1;\n            _b.label = 2;\n          case 2:\n            if (!(j < childrenIdx.length)) return [3 /*break*/, 5];\n            return [4 /*yield*/, getPotentialParent(bestChildIndex, childrenIdx[j])];\n          case 3:\n            bestChildIndex = _b.sent();\n            _b.label = 4;\n          case 4:\n            ++j;\n            return [3 /*break*/, 2];\n          case 5:\n            bestChild = this.heapArray[bestChildIndex];\n            _a = typeof bestChild !== 'undefined';\n            if (!_a) return [3 /*break*/, 7];\n            return [4 /*yield*/, this.compare(self, bestChild)];\n          case 6:\n            _a = _b.sent() > 0;\n            _b.label = 7;\n          case 7:\n            if (_a) {\n              this._moveNode(i, bestChildIndex);\n              i = bestChildIndex;\n            } else {\n              moveIt = false;\n            }\n            return [3 /*break*/, 1];\n          case 8:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Move a node up the tree (to the root) to find a place where the heap is sorted.\n   * @param  {Number} i Index of the node\n   */\n  HeapAsync.prototype._sortNodeUp = function (i) {\n    return __awaiter(this, void 0, void 0, function () {\n      var moveIt, pi, _a;\n      return __generator$1(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            moveIt = i > 0;\n            _b.label = 1;\n          case 1:\n            if (!moveIt) return [3 /*break*/, 4];\n            pi = HeapAsync.getParentIndexOf(i);\n            _a = pi >= 0;\n            if (!_a) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.compare(this.heapArray[pi], this.heapArray[i])];\n          case 2:\n            _a = _b.sent() > 0;\n            _b.label = 3;\n          case 3:\n            if (_a) {\n              this._moveNode(i, pi);\n              i = pi;\n            } else {\n              moveIt = false;\n            }\n            return [3 /*break*/, 1];\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n   * Implementation: push.\n   *\n   * @param  {Number} n  Number of elements.\n   * @return {Array}     Array of length <= N.\n   */\n  HeapAsync.prototype._topN_push = function (n) {\n    return __awaiter(this, void 0, void 0, function () {\n      var topHeap, indices, arr, i;\n      return __generator$1(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            topHeap = new HeapAsync(this._invertedCompare);\n            topHeap.limit = n;\n            indices = [0];\n            arr = this.heapArray;\n            _a.label = 1;\n          case 1:\n            if (!indices.length) return [3 /*break*/, 7];\n            i = indices.shift();\n            if (!(i < arr.length)) return [3 /*break*/, 6];\n            if (!(topHeap.length < n)) return [3 /*break*/, 3];\n            return [4 /*yield*/, topHeap.push(arr[i])];\n          case 2:\n            _a.sent();\n            indices.push.apply(indices, __spreadArray$1([], __read$1(HeapAsync.getChildrenIndexOf(i)), false));\n            return [3 /*break*/, 6];\n          case 3:\n            return [4 /*yield*/, this.compare(arr[i], topHeap.peek())];\n          case 4:\n            if (!(_a.sent() < 0)) return [3 /*break*/, 6];\n            return [4 /*yield*/, topHeap.replace(arr[i])];\n          case 5:\n            _a.sent();\n            indices.push.apply(indices, __spreadArray$1([], __read$1(HeapAsync.getChildrenIndexOf(i)), false));\n            _a.label = 6;\n          case 6:\n            return [3 /*break*/, 1];\n          case 7:\n            return [2 /*return*/, topHeap.toArray()];\n        }\n      });\n    });\n  };\n  /**\n   * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n   * Implementation: init + push.\n   *\n   * @param  {Number} n  Number of elements.\n   * @return {Array}     Array of length <= N.\n   */\n  HeapAsync.prototype._topN_fill = function (n) {\n    return __awaiter(this, void 0, void 0, function () {\n      var heapArray, topHeap, branch, indices, i, i;\n      return __generator$1(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            heapArray = this.heapArray;\n            topHeap = new HeapAsync(this._invertedCompare);\n            topHeap.limit = n;\n            topHeap.heapArray = heapArray.slice(0, n);\n            return [4 /*yield*/, topHeap.init()];\n          case 1:\n            _a.sent();\n            branch = HeapAsync.getParentIndexOf(n - 1) + 1;\n            indices = [];\n            for (i = branch; i < n; ++i) {\n              indices.push.apply(indices, __spreadArray$1([], __read$1(HeapAsync.getChildrenIndexOf(i).filter(function (l) {\n                return l < heapArray.length;\n              })), false));\n            }\n            if ((n - 1) % 2) {\n              indices.push(n);\n            }\n            _a.label = 2;\n          case 2:\n            if (!indices.length) return [3 /*break*/, 6];\n            i = indices.shift();\n            if (!(i < heapArray.length)) return [3 /*break*/, 5];\n            return [4 /*yield*/, this.compare(heapArray[i], topHeap.peek())];\n          case 3:\n            if (!(_a.sent() < 0)) return [3 /*break*/, 5];\n            return [4 /*yield*/, topHeap.replace(heapArray[i])];\n          case 4:\n            _a.sent();\n            indices.push.apply(indices, __spreadArray$1([], __read$1(HeapAsync.getChildrenIndexOf(i)), false));\n            _a.label = 5;\n          case 5:\n            return [3 /*break*/, 2];\n          case 6:\n            return [2 /*return*/, topHeap.toArray()];\n        }\n      });\n    });\n  };\n  /**\n   * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n   * Implementation: heap.\n   *\n   * @param  {Number} n  Number of elements.\n   * @return {Array}     Array of length <= N.\n   */\n  HeapAsync.prototype._topN_heap = function (n) {\n    return __awaiter(this, void 0, void 0, function () {\n      var topHeap, result, i, _a, _b;\n      return __generator$1(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            topHeap = this.clone();\n            result = [];\n            i = 0;\n            _c.label = 1;\n          case 1:\n            if (!(i < n)) return [3 /*break*/, 4];\n            _b = (_a = result).push;\n            return [4 /*yield*/, topHeap.pop()];\n          case 2:\n            _b.apply(_a, [_c.sent()]);\n            _c.label = 3;\n          case 3:\n            ++i;\n            return [3 /*break*/, 1];\n          case 4:\n            return [2 /*return*/, result];\n        }\n      });\n    });\n  };\n  /**\n   * Return index of the top element\n   * @param list\n   */\n  HeapAsync.prototype._topIdxOf = function (list) {\n    return __awaiter(this, void 0, void 0, function () {\n      var idx, top, i, comp;\n      return __generator$1(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!list.length) {\n              return [2 /*return*/, -1];\n            }\n            idx = 0;\n            top = list[idx];\n            i = 1;\n            _a.label = 1;\n          case 1:\n            if (!(i < list.length)) return [3 /*break*/, 4];\n            return [4 /*yield*/, this.compare(list[i], top)];\n          case 2:\n            comp = _a.sent();\n            if (comp < 0) {\n              idx = i;\n              top = list[i];\n            }\n            _a.label = 3;\n          case 3:\n            ++i;\n            return [3 /*break*/, 1];\n          case 4:\n            return [2 /*return*/, idx];\n        }\n      });\n    });\n  };\n  /**\n   * Return the top element\n   * @param list\n   */\n  HeapAsync.prototype._topOf = function () {\n    var list = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      list[_i] = arguments[_i];\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var heap;\n      return __generator$1(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            heap = new HeapAsync(this.compare);\n            return [4 /*yield*/, heap.init(list)];\n          case 1:\n            _a.sent();\n            return [2 /*return*/, heap.peek()];\n        }\n      });\n    });\n  };\n  return HeapAsync;\n}();\nvar __generator = undefined && undefined.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (g && (g = 0, op[0] && (_ = 0)), _) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __read = undefined && undefined.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = undefined && undefined.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar toInt = function (n) {\n  return ~~n;\n};\n/**\n * Heap\n * @type {Class}\n */\nvar Heap = /** @class */function () {\n  /**\n   * Heap instance constructor.\n   * @param  {Function} compare Optional comparison function, defaults to Heap.minComparator<number>\n   */\n  function Heap(compare) {\n    if (compare === void 0) {\n      compare = Heap.minComparator;\n    }\n    var _this = this;\n    this.compare = compare;\n    this.heapArray = [];\n    this._limit = 0;\n    /**\n     * Alias of add\n     */\n    this.offer = this.add;\n    /**\n     * Alias of peek\n     */\n    this.element = this.peek;\n    /**\n     * Alias of pop\n     */\n    this.poll = this.pop;\n    /**\n     * Returns the inverse to the comparison function.\n     * @return {Function}\n     */\n    this._invertedCompare = function (a, b) {\n      return -1 * _this.compare(a, b);\n    };\n  }\n  /*\n            Static methods\n   */\n  /**\n   * Gets children indices for given index.\n   * @param  {Number} idx     Parent index\n   * @return {Array(Number)}  Array of children indices\n   */\n  Heap.getChildrenIndexOf = function (idx) {\n    return [idx * 2 + 1, idx * 2 + 2];\n  };\n  /**\n   * Gets parent index for given index.\n   * @param  {Number} idx  Children index\n   * @return {Number | undefined}      Parent index, -1 if idx is 0\n   */\n  Heap.getParentIndexOf = function (idx) {\n    if (idx <= 0) {\n      return -1;\n    }\n    var whichChildren = idx % 2 ? 1 : 2;\n    return Math.floor((idx - whichChildren) / 2);\n  };\n  /**\n   * Gets sibling index for given index.\n   * @param  {Number} idx  Children index\n   * @return {Number | undefined}      Sibling index, -1 if idx is 0\n   */\n  Heap.getSiblingIndexOf = function (idx) {\n    if (idx <= 0) {\n      return -1;\n    }\n    var whichChildren = idx % 2 ? 1 : -1;\n    return idx + whichChildren;\n  };\n  /**\n   * Min heap comparison function, default.\n   * @param  {any} a     First element\n   * @param  {any} b     Second element\n   * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n   */\n  Heap.minComparator = function (a, b) {\n    if (a > b) {\n      return 1;\n    } else if (a < b) {\n      return -1;\n    } else {\n      return 0;\n    }\n  };\n  /**\n   * Max heap comparison function.\n   * @param  {any} a     First element\n   * @param  {any} b     Second element\n   * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n   */\n  Heap.maxComparator = function (a, b) {\n    if (b > a) {\n      return 1;\n    } else if (b < a) {\n      return -1;\n    } else {\n      return 0;\n    }\n  };\n  /**\n   * Min number heap comparison function, default.\n   * @param  {Number} a     First element\n   * @param  {Number} b     Second element\n   * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n   */\n  Heap.minComparatorNumber = function (a, b) {\n    return a - b;\n  };\n  /**\n   * Max number heap comparison function.\n   * @param  {Number} a     First element\n   * @param  {Number} b     Second element\n   * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n   */\n  Heap.maxComparatorNumber = function (a, b) {\n    return b - a;\n  };\n  /**\n   * Default equality function.\n   * @param  {any} a    First element\n   * @param  {any} b    Second element\n   * @return {Boolean}  True if equal, false otherwise\n   */\n  Heap.defaultIsEqual = function (a, b) {\n    return a === b;\n  };\n  /**\n   * Prints a heap.\n   * @param  {Heap} heap Heap to be printed\n   * @returns {String}\n   */\n  Heap.print = function (heap) {\n    function deep(i) {\n      var pi = Heap.getParentIndexOf(i);\n      return Math.floor(Math.log2(pi + 1));\n    }\n    function repeat(str, times) {\n      var out = '';\n      for (; times > 0; --times) {\n        out += str;\n      }\n      return out;\n    }\n    var node = 0;\n    var lines = [];\n    var maxLines = deep(heap.length - 1) + 2;\n    var maxLength = 0;\n    while (node < heap.length) {\n      var i = deep(node) + 1;\n      if (node === 0) {\n        i = 0;\n      }\n      // Text representation\n      var nodeText = String(heap.get(node));\n      if (nodeText.length > maxLength) {\n        maxLength = nodeText.length;\n      }\n      // Add to line\n      lines[i] = lines[i] || [];\n      lines[i].push(nodeText);\n      node += 1;\n    }\n    return lines.map(function (line, i) {\n      var times = Math.pow(2, maxLines - i) - 1;\n      return repeat(' ', Math.floor(times / 2) * maxLength) + line.map(function (el) {\n        // centered\n        var half = (maxLength - el.length) / 2;\n        return repeat(' ', Math.ceil(half)) + el + repeat(' ', Math.floor(half));\n      }).join(repeat(' ', times * maxLength));\n    }).join('\\n');\n  };\n  /*\n            Python style\n   */\n  /**\n   * Converts an array into an array-heap, in place\n   * @param  {Array}    arr      Array to be modified\n   * @param  {Function} compare  Optional compare function\n   * @return {Heap}              For convenience, it returns a Heap instance\n   */\n  Heap.heapify = function (arr, compare) {\n    var heap = new Heap(compare);\n    heap.heapArray = arr;\n    heap.init();\n    return heap;\n  };\n  /**\n   * Extract the peek of an array-heap\n   * @param  {Array}    heapArr  Array to be modified, should be a heap\n   * @param  {Function} compare  Optional compare function\n   * @return {any}               Returns the extracted peek\n   */\n  Heap.heappop = function (heapArr, compare) {\n    var heap = new Heap(compare);\n    heap.heapArray = heapArr;\n    return heap.pop();\n  };\n  /**\n   * Pushes a item into an array-heap\n   * @param  {Array}    heapArr  Array to be modified, should be a heap\n   * @param  {any}      item     Item to push\n   * @param  {Function} compare  Optional compare function\n   */\n  Heap.heappush = function (heapArr, item, compare) {\n    var heap = new Heap(compare);\n    heap.heapArray = heapArr;\n    heap.push(item);\n  };\n  /**\n   * Push followed by pop, faster\n   * @param  {Array}    heapArr  Array to be modified, should be a heap\n   * @param  {any}      item     Item to push\n   * @param  {Function} compare  Optional compare function\n   * @return {any}               Returns the extracted peek\n   */\n  Heap.heappushpop = function (heapArr, item, compare) {\n    var heap = new Heap(compare);\n    heap.heapArray = heapArr;\n    return heap.pushpop(item);\n  };\n  /**\n   * Replace peek with item\n   * @param  {Array}    heapArr  Array to be modified, should be a heap\n   * @param  {any}      item     Item as replacement\n   * @param  {Function} compare  Optional compare function\n   * @return {any}               Returns the extracted peek\n   */\n  Heap.heapreplace = function (heapArr, item, compare) {\n    var heap = new Heap(compare);\n    heap.heapArray = heapArr;\n    return heap.replace(item);\n  };\n  /**\n   * Return the `n` most valuable elements of a heap-like Array\n   * @param  {Array}    heapArr  Array, should be an array-heap\n   * @param  {number}   n        Max number of elements\n   * @param  {Function} compare  Optional compare function\n   * @return {any}               Elements\n   */\n  Heap.heaptop = function (heapArr, n, compare) {\n    if (n === void 0) {\n      n = 1;\n    }\n    var heap = new Heap(compare);\n    heap.heapArray = heapArr;\n    return heap.top(n);\n  };\n  /**\n   * Return the `n` least valuable elements of a heap-like Array\n   * @param  {Array}    heapArr  Array, should be an array-heap\n   * @param  {number}   n        Max number of elements\n   * @param  {Function} compare  Optional compare function\n   * @return {any}               Elements\n   */\n  Heap.heapbottom = function (heapArr, n, compare) {\n    if (n === void 0) {\n      n = 1;\n    }\n    var heap = new Heap(compare);\n    heap.heapArray = heapArr;\n    return heap.bottom(n);\n  };\n  /**\n   * Return the `n` most valuable elements of an iterable\n   * @param  {number}   n        Max number of elements\n   * @param  {Iterable} Iterable Iterable list of elements\n   * @param  {Function} compare  Optional compare function\n   * @return {any}               Elements\n   */\n  Heap.nlargest = function (n, iterable, compare) {\n    var heap = new Heap(compare);\n    heap.heapArray = __spreadArray([], __read(iterable), false);\n    heap.init();\n    return heap.top(n);\n  };\n  /**\n   * Return the `n` least valuable elements of an iterable\n   * @param  {number}   n        Max number of elements\n   * @param  {Iterable} Iterable Iterable list of elements\n   * @param  {Function} compare  Optional compare function\n   * @return {any}               Elements\n   */\n  Heap.nsmallest = function (n, iterable, compare) {\n    var heap = new Heap(compare);\n    heap.heapArray = __spreadArray([], __read(iterable), false);\n    heap.init();\n    return heap.bottom(n);\n  };\n  /*\n            Instance methods\n   */\n  /**\n   * Adds an element to the heap. Aliases: `offer`.\n   * Same as: push(element)\n   * @param {any} element Element to be added\n   * @return {Boolean} true\n   */\n  Heap.prototype.add = function (element) {\n    this._sortNodeUp(this.heapArray.push(element) - 1);\n    this._applyLimit();\n    return true;\n  };\n  /**\n   * Adds an array of elements to the heap.\n   * Similar as: push(element, element, ...).\n   * @param {Array} elements Elements to be added\n   * @return {Boolean} true\n   */\n  Heap.prototype.addAll = function (elements) {\n    var _a;\n    var i = this.length;\n    (_a = this.heapArray).push.apply(_a, __spreadArray([], __read(elements), false));\n    for (var l = this.length; i < l; ++i) {\n      this._sortNodeUp(i);\n    }\n    this._applyLimit();\n    return true;\n  };\n  /**\n   * Return the bottom (lowest value) N elements of the heap.\n   *\n   * @param  {Number} n  Number of elements.\n   * @return {Array}     Array of length <= N.\n   */\n  Heap.prototype.bottom = function (n) {\n    if (n === void 0) {\n      n = 1;\n    }\n    if (this.heapArray.length === 0 || n <= 0) {\n      // Nothing to do\n      return [];\n    } else if (this.heapArray.length === 1) {\n      // Just the peek\n      return [this.heapArray[0]];\n    } else if (n >= this.heapArray.length) {\n      // The whole heap\n      return __spreadArray([], __read(this.heapArray), false);\n    } else {\n      // Some elements\n      return this._bottomN_push(~~n);\n    }\n  };\n  /**\n   * Check if the heap is sorted, useful for testing purposes.\n   * @return {Undefined | Element}  Returns an element if something wrong is found, otherwise it's undefined\n   */\n  Heap.prototype.check = function () {\n    var _this = this;\n    return this.heapArray.find(function (el, j) {\n      return !!_this.getChildrenOf(j).find(function (ch) {\n        return _this.compare(el, ch) > 0;\n      });\n    });\n  };\n  /**\n   * Remove all of the elements from this heap.\n   */\n  Heap.prototype.clear = function () {\n    this.heapArray = [];\n  };\n  /**\n   * Clone this heap\n   * @return {Heap}\n   */\n  Heap.prototype.clone = function () {\n    var cloned = new Heap(this.comparator());\n    cloned.heapArray = this.toArray();\n    cloned._limit = this._limit;\n    return cloned;\n  };\n  /**\n   * Returns the comparison function.\n   * @return {Function}\n   */\n  Heap.prototype.comparator = function () {\n    return this.compare;\n  };\n  /**\n   * Returns true if this queue contains the specified element.\n   * @param  {any}      o   Element to be found\n   * @param  {Function} fn  Optional comparison function, receives (element, needle)\n   * @return {Boolean}\n   */\n  Heap.prototype.contains = function (o, fn) {\n    if (fn === void 0) {\n      fn = Heap.defaultIsEqual;\n    }\n    return this.heapArray.findIndex(function (el) {\n      return fn(el, o);\n    }) >= 0;\n  };\n  /**\n   * Initialise a heap, sorting nodes\n   * @param  {Array} array Optional initial state array\n   */\n  Heap.prototype.init = function (array) {\n    if (array) {\n      this.heapArray = __spreadArray([], __read(array), false);\n    }\n    for (var i = Math.floor(this.heapArray.length); i >= 0; --i) {\n      this._sortNodeDown(i);\n    }\n    this._applyLimit();\n  };\n  /**\n   * Test if the heap has no elements.\n   * @return {Boolean} True if no elements on the heap\n   */\n  Heap.prototype.isEmpty = function () {\n    return this.length === 0;\n  };\n  /**\n   * Get the leafs of the tree (no children nodes)\n   */\n  Heap.prototype.leafs = function () {\n    if (this.heapArray.length === 0) {\n      return [];\n    }\n    var pi = Heap.getParentIndexOf(this.heapArray.length - 1);\n    return this.heapArray.slice(pi + 1);\n  };\n  Object.defineProperty(Heap.prototype, \"length\", {\n    /**\n     * Length of the heap.\n     * @return {Number}\n     */\n    get: function () {\n      return this.heapArray.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Heap.prototype, \"limit\", {\n    /**\n     * Get length limit of the heap.\n     * @return {Number}\n     */\n    get: function () {\n      return this._limit;\n    },\n    /**\n     * Set length limit of the heap.\n     * @return {Number}\n     */\n    set: function (_l) {\n      this._limit = ~~_l;\n      this._applyLimit();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Top node. Aliases: `element`.\n   * Same as: `top(1)[0]`\n   * @return {any} Top node\n   */\n  Heap.prototype.peek = function () {\n    return this.heapArray[0];\n  };\n  /**\n   * Extract the top node (root). Aliases: `poll`.\n   * @return {any} Extracted top node, undefined if empty\n   */\n  Heap.prototype.pop = function () {\n    var last = this.heapArray.pop();\n    if (this.length > 0 && last !== undefined) {\n      return this.replace(last);\n    }\n    return last;\n  };\n  /**\n   * Pushes element(s) to the heap.\n   * @param  {...any} elements Elements to insert\n   * @return {Boolean} True if elements are present\n   */\n  Heap.prototype.push = function () {\n    var elements = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      elements[_i] = arguments[_i];\n    }\n    if (elements.length < 1) {\n      return false;\n    } else if (elements.length === 1) {\n      return this.add(elements[0]);\n    } else {\n      return this.addAll(elements);\n    }\n  };\n  /**\n   * Same as push & pop in sequence, but faster\n   * @param  {any} element Element to insert\n   * @return {any}  Extracted top node\n   */\n  Heap.prototype.pushpop = function (element) {\n    var _a;\n    if (this.compare(this.heapArray[0], element) < 0) {\n      _a = __read([this.heapArray[0], element], 2), element = _a[0], this.heapArray[0] = _a[1];\n      this._sortNodeDown(0);\n    }\n    return element;\n  };\n  /**\n   * Remove an element from the heap.\n   * @param  {any}   o      Element to be found\n   * @param  {Function} fn  Optional function to compare\n   * @return {Boolean}      True if the heap was modified\n   */\n  Heap.prototype.remove = function (o, fn) {\n    if (fn === void 0) {\n      fn = Heap.defaultIsEqual;\n    }\n    if (this.length > 0) {\n      if (o === undefined) {\n        this.pop();\n        return true;\n      } else {\n        var idx = this.heapArray.findIndex(function (el) {\n          return fn(el, o);\n        });\n        if (idx >= 0) {\n          if (idx === 0) {\n            this.pop();\n          } else if (idx === this.length - 1) {\n            this.heapArray.pop();\n          } else {\n            this.heapArray.splice(idx, 1, this.heapArray.pop());\n            this._sortNodeUp(idx);\n            this._sortNodeDown(idx);\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  /**\n   * Pop the current peek value, and add the new item.\n   * @param  {any} element  Element to replace peek\n   * @return {any}         Old peek\n   */\n  Heap.prototype.replace = function (element) {\n    var peek = this.heapArray[0];\n    this.heapArray[0] = element;\n    this._sortNodeDown(0);\n    return peek;\n  };\n  /**\n   * Size of the heap\n   * @return {Number}\n   */\n  Heap.prototype.size = function () {\n    return this.length;\n  };\n  /**\n   * Return the top (highest value) N elements of the heap.\n   *\n   * @param  {Number} n  Number of elements.\n   * @return {Array}    Array of length <= N.\n   */\n  Heap.prototype.top = function (n) {\n    if (n === void 0) {\n      n = 1;\n    }\n    if (this.heapArray.length === 0 || n <= 0) {\n      // Nothing to do\n      return [];\n    } else if (this.heapArray.length === 1 || n === 1) {\n      // Just the peek\n      return [this.heapArray[0]];\n    } else if (n >= this.heapArray.length) {\n      // The whole peek\n      return __spreadArray([], __read(this.heapArray), false);\n    } else {\n      // Some elements\n      return this._topN_push(~~n);\n    }\n  };\n  /**\n   * Clone the heap's internal array\n   * @return {Array}\n   */\n  Heap.prototype.toArray = function () {\n    return __spreadArray([], __read(this.heapArray), false);\n  };\n  /**\n   * String output, call to Array.prototype.toString()\n   * @return {String}\n   */\n  Heap.prototype.toString = function () {\n    return this.heapArray.toString();\n  };\n  /**\n   * Get the element at the given index.\n   * @param  {Number} i Index to get\n   * @return {any}       Element at that index\n   */\n  Heap.prototype.get = function (i) {\n    return this.heapArray[i];\n  };\n  /**\n   * Get the elements of these node's children\n   * @param  {Number} idx Node index\n   * @return {Array(any)}  Children elements\n   */\n  Heap.prototype.getChildrenOf = function (idx) {\n    var _this = this;\n    return Heap.getChildrenIndexOf(idx).map(function (i) {\n      return _this.heapArray[i];\n    }).filter(function (e) {\n      return e !== undefined;\n    });\n  };\n  /**\n   * Get the element of this node's parent\n   * @param  {Number} idx Node index\n   * @return {any}     Parent element\n   */\n  Heap.prototype.getParentOf = function (idx) {\n    var pi = Heap.getParentIndexOf(idx);\n    return this.heapArray[pi];\n  };\n  /**\n   * Iterator interface\n   */\n  Heap.prototype[Symbol.iterator] = function () {\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!this.length) return [3 /*break*/, 2];\n          return [4 /*yield*/, this.pop()];\n        case 1:\n          _a.sent();\n          return [3 /*break*/, 0];\n        case 2:\n          return [2 /*return*/];\n      }\n    });\n  };\n  /**\n   * Returns an iterator. To comply with Java interface.\n   */\n  Heap.prototype.iterator = function () {\n    return this.toArray();\n  };\n  /**\n   * Limit heap size if needed\n   */\n  Heap.prototype._applyLimit = function () {\n    if (this._limit && this._limit < this.heapArray.length) {\n      var rm = this.heapArray.length - this._limit;\n      // It's much faster than splice\n      while (rm) {\n        this.heapArray.pop();\n        --rm;\n      }\n    }\n  };\n  /**\n   * Return the bottom (lowest value) N elements of the heap, without corner cases, unsorted\n   *\n   * @param  {Number} n  Number of elements.\n   * @return {Array}     Array of length <= N.\n   */\n  Heap.prototype._bottomN_push = function (n) {\n    // Use an inverted heap\n    var bottomHeap = new Heap(this.compare);\n    bottomHeap.limit = n;\n    bottomHeap.heapArray = this.heapArray.slice(-n);\n    bottomHeap.init();\n    var startAt = this.heapArray.length - 1 - n;\n    var parentStartAt = Heap.getParentIndexOf(startAt);\n    var indices = [];\n    for (var i = startAt; i > parentStartAt; --i) {\n      indices.push(i);\n    }\n    var arr = this.heapArray;\n    while (indices.length) {\n      var i = indices.shift();\n      if (this.compare(arr[i], bottomHeap.peek()) > 0) {\n        bottomHeap.replace(arr[i]);\n        if (i % 2) {\n          indices.push(Heap.getParentIndexOf(i));\n        }\n      }\n    }\n    return bottomHeap.toArray();\n  };\n  /**\n   * Move a node to a new index, switching places\n   * @param  {Number} j First node index\n   * @param  {Number} k Another node index\n   */\n  Heap.prototype._moveNode = function (j, k) {\n    var _a;\n    _a = __read([this.heapArray[k], this.heapArray[j]], 2), this.heapArray[j] = _a[0], this.heapArray[k] = _a[1];\n  };\n  /**\n   * Move a node down the tree (to the leaves) to find a place where the heap is sorted.\n   * @param  {Number} i Index of the node\n   */\n  Heap.prototype._sortNodeDown = function (i) {\n    var _this = this;\n    var moveIt = i < this.heapArray.length - 1;\n    var self = this.heapArray[i];\n    var getPotentialParent = function (best, j) {\n      if (_this.heapArray.length > j && _this.compare(_this.heapArray[j], _this.heapArray[best]) < 0) {\n        best = j;\n      }\n      return best;\n    };\n    while (moveIt) {\n      var childrenIdx = Heap.getChildrenIndexOf(i);\n      var bestChildIndex = childrenIdx.reduce(getPotentialParent, childrenIdx[0]);\n      var bestChild = this.heapArray[bestChildIndex];\n      if (typeof bestChild !== 'undefined' && this.compare(self, bestChild) > 0) {\n        this._moveNode(i, bestChildIndex);\n        i = bestChildIndex;\n      } else {\n        moveIt = false;\n      }\n    }\n  };\n  /**\n   * Move a node up the tree (to the root) to find a place where the heap is sorted.\n   * @param  {Number} i Index of the node\n   */\n  Heap.prototype._sortNodeUp = function (i) {\n    var moveIt = i > 0;\n    while (moveIt) {\n      var pi = Heap.getParentIndexOf(i);\n      if (pi >= 0 && this.compare(this.heapArray[pi], this.heapArray[i]) > 0) {\n        this._moveNode(i, pi);\n        i = pi;\n      } else {\n        moveIt = false;\n      }\n    }\n  };\n  /**\n   * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n   * Implementation: push.\n   *\n   * @param  {Number} n  Number of elements.\n   * @return {Array}     Array of length <= N.\n   */\n  Heap.prototype._topN_push = function (n) {\n    // Use an inverted heap\n    var topHeap = new Heap(this._invertedCompare);\n    topHeap.limit = n;\n    var indices = [0];\n    var arr = this.heapArray;\n    while (indices.length) {\n      var i = indices.shift();\n      if (i < arr.length) {\n        if (topHeap.length < n) {\n          topHeap.push(arr[i]);\n          indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i)), false));\n        } else if (this.compare(arr[i], topHeap.peek()) < 0) {\n          topHeap.replace(arr[i]);\n          indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i)), false));\n        }\n      }\n    }\n    return topHeap.toArray();\n  };\n  /**\n   * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n   * Implementation: init + push.\n   *\n   * @param  {Number} n  Number of elements.\n   * @return {Array}     Array of length <= N.\n   */\n  Heap.prototype._topN_fill = function (n) {\n    // Use an inverted heap\n    var heapArray = this.heapArray;\n    var topHeap = new Heap(this._invertedCompare);\n    topHeap.limit = n;\n    topHeap.heapArray = heapArray.slice(0, n);\n    topHeap.init();\n    var branch = Heap.getParentIndexOf(n - 1) + 1;\n    var indices = [];\n    for (var i = branch; i < n; ++i) {\n      indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i).filter(function (l) {\n        return l < heapArray.length;\n      })), false));\n    }\n    if ((n - 1) % 2) {\n      indices.push(n);\n    }\n    while (indices.length) {\n      var i = indices.shift();\n      if (i < heapArray.length) {\n        if (this.compare(heapArray[i], topHeap.peek()) < 0) {\n          topHeap.replace(heapArray[i]);\n          indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i)), false));\n        }\n      }\n    }\n    return topHeap.toArray();\n  };\n  /**\n   * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n   * Implementation: heap.\n   *\n   * @param  {Number} n  Number of elements.\n   * @return {Array}     Array of length <= N.\n   */\n  Heap.prototype._topN_heap = function (n) {\n    var topHeap = this.clone();\n    var result = [];\n    for (var i = 0; i < n; ++i) {\n      result.push(topHeap.pop());\n    }\n    return result;\n  };\n  /**\n   * Return index of the top element\n   * @param list\n   */\n  Heap.prototype._topIdxOf = function (list) {\n    if (!list.length) {\n      return -1;\n    }\n    var idx = 0;\n    var top = list[idx];\n    for (var i = 1; i < list.length; ++i) {\n      var comp = this.compare(list[i], top);\n      if (comp < 0) {\n        idx = i;\n        top = list[i];\n      }\n    }\n    return idx;\n  };\n  /**\n   * Return the top element\n   * @param list\n   */\n  Heap.prototype._topOf = function () {\n    var list = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      list[_i] = arguments[_i];\n    }\n    var heap = new Heap(this.compare);\n    heap.init(list);\n    return heap.peek();\n  };\n  return Heap;\n}();\nexport { Heap, HeapAsync, Heap as default, toInt };","map":{"version":3,"names":["__awaiter","undefined","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__generator$1","__generator","body","_","label","sent","t","trys","ops","f","y","g","verb","Symbol","iterator","n","v","op","TypeError","call","pop","length","push","__read$1","__read","o","m","i","r","ar","error","__spreadArray$1","__spreadArray","to","from","pack","arguments","l","Array","prototype","slice","concat","__values","s","HeapAsync","compare","minComparator","_this","heapArray","_limit","offer","add","element","peek","poll","_invertedCompare","a","b","res","getChildrenIndexOf","idx","getParentIndexOf","whichChildren","Math","floor","getSiblingIndexOf","_a","maxComparator","minComparatorNumber","maxComparatorNumber","defaultIsEqual","print","heap","deep","pi","log2","repeat","str","times","out","node","lines","maxLines","maxLength","nodeText","String","get","map","line","pow","el","half","ceil","join","heapify","arr","init","heappop","heapArr","heappush","item","heappushpop","pushpop","heapreplace","replace","heaptop","top","heapbottom","bottom","nlargest","iterable","nsmallest","_sortNodeUp","_applyLimit","addAll","elements","_b","_bottomN_push","check","j","children","children_1","children_1_1","ch","e_1_1","e_1","getChildrenOf","return","clear","clone","cloned","comparator","toArray","contains","fn","e_2_1","e_2","_c","_d","array","_sortNodeDown","isEmpty","leafs","Object","defineProperty","enumerable","configurable","set","_l","last","_i","remove","splice","size","_topN_push","toString","filter","getParentOf","rm","bottomHeap","startAt","parentStartAt","indices","limit","shift","_moveNode","k","moveIt","self","getPotentialParent","childrenIdx","bestChildIndex","bestChild","best","topHeap","_topN_fill","branch","_topN_heap","_topIdxOf","list","comp","_topOf","toInt","Heap","find","findIndex","reduce","default"],"sources":["C:/Users//clone/node_modules/heap-js/dist/heap-js.es5.js"],"sourcesContent":["var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator$1 = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read$1 = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray$1 = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __values = (undefined && undefined.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n/**\n * Heap\n * @type {Class}\n */\nvar HeapAsync = /** @class */ (function () {\n    /**\n     * Heap instance constructor.\n     * @param  {Function} compare Optional comparison function, defaults to Heap.minComparator<number>\n     */\n    function HeapAsync(compare) {\n        if (compare === void 0) { compare = HeapAsync.minComparator; }\n        var _this = this;\n        this.compare = compare;\n        this.heapArray = [];\n        this._limit = 0;\n        /**\n         * Alias of add\n         */\n        this.offer = this.add;\n        /**\n         * Alias of peek\n         */\n        this.element = this.peek;\n        /**\n         * Alias of pop\n         */\n        this.poll = this.pop;\n        /**\n         * Returns the inverse to the comparison function.\n         * @return {Number}\n         */\n        this._invertedCompare = function (a, b) {\n            return _this.compare(a, b).then(function (res) { return -1 * res; });\n        };\n    }\n    /*\n              Static methods\n     */\n    /**\n     * Gets children indices for given index.\n     * @param  {Number} idx     Parent index\n     * @return {Array(Number)}  Array of children indices\n     */\n    HeapAsync.getChildrenIndexOf = function (idx) {\n        return [idx * 2 + 1, idx * 2 + 2];\n    };\n    /**\n     * Gets parent index for given index.\n     * @param  {Number} idx  Children index\n     * @return {Number | undefined}      Parent index, -1 if idx is 0\n     */\n    HeapAsync.getParentIndexOf = function (idx) {\n        if (idx <= 0) {\n            return -1;\n        }\n        var whichChildren = idx % 2 ? 1 : 2;\n        return Math.floor((idx - whichChildren) / 2);\n    };\n    /**\n     * Gets sibling index for given index.\n     * @param  {Number} idx  Children index\n     * @return {Number | undefined}      Sibling index, -1 if idx is 0\n     */\n    HeapAsync.getSiblingIndexOf = function (idx) {\n        if (idx <= 0) {\n            return -1;\n        }\n        var whichChildren = idx % 2 ? 1 : -1;\n        return idx + whichChildren;\n    };\n    /**\n     * Min heap comparison function, default.\n     * @param  {any} a     First element\n     * @param  {any} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    HeapAsync.minComparator = function (a, b) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator$1(this, function (_a) {\n                if (a > b) {\n                    return [2 /*return*/, 1];\n                }\n                else if (a < b) {\n                    return [2 /*return*/, -1];\n                }\n                else {\n                    return [2 /*return*/, 0];\n                }\n            });\n        });\n    };\n    /**\n     * Max heap comparison function.\n     * @param  {any} a     First element\n     * @param  {any} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    HeapAsync.maxComparator = function (a, b) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator$1(this, function (_a) {\n                if (b > a) {\n                    return [2 /*return*/, 1];\n                }\n                else if (b < a) {\n                    return [2 /*return*/, -1];\n                }\n                else {\n                    return [2 /*return*/, 0];\n                }\n            });\n        });\n    };\n    /**\n     * Min number heap comparison function, default.\n     * @param  {Number} a     First element\n     * @param  {Number} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    HeapAsync.minComparatorNumber = function (a, b) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator$1(this, function (_a) {\n                return [2 /*return*/, a - b];\n            });\n        });\n    };\n    /**\n     * Max number heap comparison function.\n     * @param  {Number} a     First element\n     * @param  {Number} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    HeapAsync.maxComparatorNumber = function (a, b) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator$1(this, function (_a) {\n                return [2 /*return*/, b - a];\n            });\n        });\n    };\n    /**\n     * Default equality function.\n     * @param  {any} a    First element\n     * @param  {any} b    Second element\n     * @return {Boolean}  True if equal, false otherwise\n     */\n    HeapAsync.defaultIsEqual = function (a, b) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator$1(this, function (_a) {\n                return [2 /*return*/, a === b];\n            });\n        });\n    };\n    /**\n     * Prints a heap.\n     * @param  {HeapAsync} heap Heap to be printed\n     * @returns {String}\n     */\n    HeapAsync.print = function (heap) {\n        function deep(i) {\n            var pi = HeapAsync.getParentIndexOf(i);\n            return Math.floor(Math.log2(pi + 1));\n        }\n        function repeat(str, times) {\n            var out = '';\n            for (; times > 0; --times) {\n                out += str;\n            }\n            return out;\n        }\n        var node = 0;\n        var lines = [];\n        var maxLines = deep(heap.length - 1) + 2;\n        var maxLength = 0;\n        while (node < heap.length) {\n            var i = deep(node) + 1;\n            if (node === 0) {\n                i = 0;\n            }\n            // Text representation\n            var nodeText = String(heap.get(node));\n            if (nodeText.length > maxLength) {\n                maxLength = nodeText.length;\n            }\n            // Add to line\n            lines[i] = lines[i] || [];\n            lines[i].push(nodeText);\n            node += 1;\n        }\n        return lines\n            .map(function (line, i) {\n            var times = Math.pow(2, maxLines - i) - 1;\n            return (repeat(' ', Math.floor(times / 2) * maxLength) +\n                line\n                    .map(function (el) {\n                    // centered\n                    var half = (maxLength - el.length) / 2;\n                    return repeat(' ', Math.ceil(half)) + el + repeat(' ', Math.floor(half));\n                })\n                    .join(repeat(' ', times * maxLength)));\n        })\n            .join('\\n');\n    };\n    /*\n              Python style\n     */\n    /**\n     * Converts an array into an array-heap, in place\n     * @param  {Array}    arr      Array to be modified\n     * @param  {Function} compare  Optional compare function\n     * @return {HeapAsync}              For convenience, it returns a Heap instance\n     */\n    HeapAsync.heapify = function (arr, compare) {\n        return __awaiter(this, void 0, void 0, function () {\n            var heap;\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        heap = new HeapAsync(compare);\n                        heap.heapArray = arr;\n                        return [4 /*yield*/, heap.init()];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, heap];\n                }\n            });\n        });\n    };\n    /**\n     * Extract the peek of an array-heap\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Returns the extracted peek\n     */\n    HeapAsync.heappop = function (heapArr, compare) {\n        var heap = new HeapAsync(compare);\n        heap.heapArray = heapArr;\n        return heap.pop();\n    };\n    /**\n     * Pushes a item into an array-heap\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {any}      item     Item to push\n     * @param  {Function} compare  Optional compare function\n     */\n    HeapAsync.heappush = function (heapArr, item, compare) {\n        return __awaiter(this, void 0, void 0, function () {\n            var heap;\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        heap = new HeapAsync(compare);\n                        heap.heapArray = heapArr;\n                        return [4 /*yield*/, heap.push(item)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Push followed by pop, faster\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {any}      item     Item to push\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Returns the extracted peek\n     */\n    HeapAsync.heappushpop = function (heapArr, item, compare) {\n        var heap = new HeapAsync(compare);\n        heap.heapArray = heapArr;\n        return heap.pushpop(item);\n    };\n    /**\n     * Replace peek with item\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {any}      item     Item as replacement\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Returns the extracted peek\n     */\n    HeapAsync.heapreplace = function (heapArr, item, compare) {\n        var heap = new HeapAsync(compare);\n        heap.heapArray = heapArr;\n        return heap.replace(item);\n    };\n    /**\n     * Return the `n` most valuable elements of a heap-like Array\n     * @param  {Array}    heapArr  Array, should be an array-heap\n     * @param  {number}   n        Max number of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    HeapAsync.heaptop = function (heapArr, n, compare) {\n        if (n === void 0) { n = 1; }\n        var heap = new HeapAsync(compare);\n        heap.heapArray = heapArr;\n        return heap.top(n);\n    };\n    /**\n     * Return the `n` least valuable elements of a heap-like Array\n     * @param  {Array}    heapArr  Array, should be an array-heap\n     * @param  {number}   n        Max number of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    HeapAsync.heapbottom = function (heapArr, n, compare) {\n        if (n === void 0) { n = 1; }\n        var heap = new HeapAsync(compare);\n        heap.heapArray = heapArr;\n        return heap.bottom(n);\n    };\n    /**\n     * Return the `n` most valuable elements of an iterable\n     * @param  {number}   n        Max number of elements\n     * @param  {Iterable} Iterable Iterable list of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    HeapAsync.nlargest = function (n, iterable, compare) {\n        return __awaiter(this, void 0, void 0, function () {\n            var heap;\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        heap = new HeapAsync(compare);\n                        heap.heapArray = __spreadArray$1([], __read$1(iterable), false);\n                        return [4 /*yield*/, heap.init()];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, heap.top(n)];\n                }\n            });\n        });\n    };\n    /**\n     * Return the `n` least valuable elements of an iterable\n     * @param  {number}   n        Max number of elements\n     * @param  {Iterable} Iterable Iterable list of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    HeapAsync.nsmallest = function (n, iterable, compare) {\n        return __awaiter(this, void 0, void 0, function () {\n            var heap;\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        heap = new HeapAsync(compare);\n                        heap.heapArray = __spreadArray$1([], __read$1(iterable), false);\n                        return [4 /*yield*/, heap.init()];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, heap.bottom(n)];\n                }\n            });\n        });\n    };\n    /*\n              Instance methods\n     */\n    /**\n     * Adds an element to the heap. Aliases: `offer`.\n     * Same as: push(element)\n     * @param {any} element Element to be added\n     * @return {Boolean} true\n     */\n    HeapAsync.prototype.add = function (element) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._sortNodeUp(this.heapArray.push(element) - 1)];\n                    case 1:\n                        _a.sent();\n                        this._applyLimit();\n                        return [2 /*return*/, true];\n                }\n            });\n        });\n    };\n    /**\n     * Adds an array of elements to the heap.\n     * Similar as: push(element, element, ...).\n     * @param {Array} elements Elements to be added\n     * @return {Boolean} true\n     */\n    HeapAsync.prototype.addAll = function (elements) {\n        return __awaiter(this, void 0, void 0, function () {\n            var i, l;\n            var _a;\n            return __generator$1(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        i = this.length;\n                        (_a = this.heapArray).push.apply(_a, __spreadArray$1([], __read$1(elements), false));\n                        l = this.length;\n                        _b.label = 1;\n                    case 1:\n                        if (!(i < l)) return [3 /*break*/, 4];\n                        return [4 /*yield*/, this._sortNodeUp(i)];\n                    case 2:\n                        _b.sent();\n                        _b.label = 3;\n                    case 3:\n                        ++i;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        this._applyLimit();\n                        return [2 /*return*/, true];\n                }\n            });\n        });\n    };\n    /**\n     * Return the bottom (lowest value) N elements of the heap.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    HeapAsync.prototype.bottom = function (n) {\n        if (n === void 0) { n = 1; }\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator$1(this, function (_a) {\n                if (this.heapArray.length === 0 || n <= 0) {\n                    // Nothing to do\n                    return [2 /*return*/, []];\n                }\n                else if (this.heapArray.length === 1) {\n                    // Just the peek\n                    return [2 /*return*/, [this.heapArray[0]]];\n                }\n                else if (n >= this.heapArray.length) {\n                    // The whole heap\n                    return [2 /*return*/, __spreadArray$1([], __read$1(this.heapArray), false)];\n                }\n                else {\n                    // Some elements\n                    return [2 /*return*/, this._bottomN_push(~~n)];\n                }\n            });\n        });\n    };\n    /**\n     * Check if the heap is sorted, useful for testing purposes.\n     * @return {Undefined | Element}  Returns an element if something wrong is found, otherwise it's undefined\n     */\n    HeapAsync.prototype.check = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var j, el, children, children_1, children_1_1, ch, e_1_1;\n            var e_1, _a;\n            return __generator$1(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        j = 0;\n                        _b.label = 1;\n                    case 1:\n                        if (!(j < this.heapArray.length)) return [3 /*break*/, 10];\n                        el = this.heapArray[j];\n                        children = this.getChildrenOf(j);\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, 7, 8, 9]);\n                        children_1 = (e_1 = void 0, __values(children)), children_1_1 = children_1.next();\n                        _b.label = 3;\n                    case 3:\n                        if (!!children_1_1.done) return [3 /*break*/, 6];\n                        ch = children_1_1.value;\n                        return [4 /*yield*/, this.compare(el, ch)];\n                    case 4:\n                        if ((_b.sent()) > 0) {\n                            return [2 /*return*/, el];\n                        }\n                        _b.label = 5;\n                    case 5:\n                        children_1_1 = children_1.next();\n                        return [3 /*break*/, 3];\n                    case 6: return [3 /*break*/, 9];\n                    case 7:\n                        e_1_1 = _b.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 9];\n                    case 8:\n                        try {\n                            if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                        return [7 /*endfinally*/];\n                    case 9:\n                        ++j;\n                        return [3 /*break*/, 1];\n                    case 10: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Remove all of the elements from this heap.\n     */\n    HeapAsync.prototype.clear = function () {\n        this.heapArray = [];\n    };\n    /**\n     * Clone this heap\n     * @return {HeapAsync}\n     */\n    HeapAsync.prototype.clone = function () {\n        var cloned = new HeapAsync(this.comparator());\n        cloned.heapArray = this.toArray();\n        cloned._limit = this._limit;\n        return cloned;\n    };\n    /**\n     * Returns the comparison function.\n     * @return {Function}\n     */\n    HeapAsync.prototype.comparator = function () {\n        return this.compare;\n    };\n    /**\n     * Returns true if this queue contains the specified element.\n     * @param  {any}      o   Element to be found\n     * @param  {Function} fn  Optional comparison function, receives (element, needle)\n     * @return {Boolean}\n     */\n    HeapAsync.prototype.contains = function (o, fn) {\n        if (fn === void 0) { fn = HeapAsync.defaultIsEqual; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b, el, e_2_1;\n            var e_2, _c;\n            return __generator$1(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        _d.trys.push([0, 5, 6, 7]);\n                        _a = __values(this.heapArray), _b = _a.next();\n                        _d.label = 1;\n                    case 1:\n                        if (!!_b.done) return [3 /*break*/, 4];\n                        el = _b.value;\n                        return [4 /*yield*/, fn(el, o)];\n                    case 2:\n                        if (_d.sent()) {\n                            return [2 /*return*/, true];\n                        }\n                        _d.label = 3;\n                    case 3:\n                        _b = _a.next();\n                        return [3 /*break*/, 1];\n                    case 4: return [3 /*break*/, 7];\n                    case 5:\n                        e_2_1 = _d.sent();\n                        e_2 = { error: e_2_1 };\n                        return [3 /*break*/, 7];\n                    case 6:\n                        try {\n                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n                        }\n                        finally { if (e_2) throw e_2.error; }\n                        return [7 /*endfinally*/];\n                    case 7: return [2 /*return*/, false];\n                }\n            });\n        });\n    };\n    /**\n     * Initialise a heap, sorting nodes\n     * @param  {Array} array Optional initial state array\n     */\n    HeapAsync.prototype.init = function (array) {\n        return __awaiter(this, void 0, void 0, function () {\n            var i;\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (array) {\n                            this.heapArray = __spreadArray$1([], __read$1(array), false);\n                        }\n                        i = Math.floor(this.heapArray.length);\n                        _a.label = 1;\n                    case 1:\n                        if (!(i >= 0)) return [3 /*break*/, 4];\n                        return [4 /*yield*/, this._sortNodeDown(i)];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3:\n                        --i;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        this._applyLimit();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Test if the heap has no elements.\n     * @return {Boolean} True if no elements on the heap\n     */\n    HeapAsync.prototype.isEmpty = function () {\n        return this.length === 0;\n    };\n    /**\n     * Get the leafs of the tree (no children nodes)\n     */\n    HeapAsync.prototype.leafs = function () {\n        if (this.heapArray.length === 0) {\n            return [];\n        }\n        var pi = HeapAsync.getParentIndexOf(this.heapArray.length - 1);\n        return this.heapArray.slice(pi + 1);\n    };\n    Object.defineProperty(HeapAsync.prototype, \"length\", {\n        /**\n         * Length of the heap.\n         * @return {Number}\n         */\n        get: function () {\n            return this.heapArray.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(HeapAsync.prototype, \"limit\", {\n        /**\n         * Get length limit of the heap.\n         * @return {Number}\n         */\n        get: function () {\n            return this._limit;\n        },\n        /**\n         * Set length limit of the heap.\n         * @return {Number}\n         */\n        set: function (_l) {\n            this._limit = ~~_l;\n            this._applyLimit();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Top node. Aliases: `element`.\n     * Same as: `top(1)[0]`\n     * @return {any} Top node\n     */\n    HeapAsync.prototype.peek = function () {\n        return this.heapArray[0];\n    };\n    /**\n     * Extract the top node (root). Aliases: `poll`.\n     * @return {any} Extracted top node, undefined if empty\n     */\n    HeapAsync.prototype.pop = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var last;\n            return __generator$1(this, function (_a) {\n                last = this.heapArray.pop();\n                if (this.length > 0 && last !== undefined) {\n                    return [2 /*return*/, this.replace(last)];\n                }\n                return [2 /*return*/, last];\n            });\n        });\n    };\n    /**\n     * Pushes element(s) to the heap.\n     * @param  {...any} elements Elements to insert\n     * @return {Boolean} True if elements are present\n     */\n    HeapAsync.prototype.push = function () {\n        var elements = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            elements[_i] = arguments[_i];\n        }\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator$1(this, function (_a) {\n                if (elements.length < 1) {\n                    return [2 /*return*/, false];\n                }\n                else if (elements.length === 1) {\n                    return [2 /*return*/, this.add(elements[0])];\n                }\n                else {\n                    return [2 /*return*/, this.addAll(elements)];\n                }\n            });\n        });\n    };\n    /**\n     * Same as push & pop in sequence, but faster\n     * @param  {any} element Element to insert\n     * @return {any}  Extracted top node\n     */\n    HeapAsync.prototype.pushpop = function (element) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator$1(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, this.compare(this.heapArray[0], element)];\n                    case 1:\n                        if (!((_b.sent()) < 0)) return [3 /*break*/, 3];\n                        _a = __read$1([this.heapArray[0], element], 2), element = _a[0], this.heapArray[0] = _a[1];\n                        return [4 /*yield*/, this._sortNodeDown(0)];\n                    case 2:\n                        _b.sent();\n                        _b.label = 3;\n                    case 3: return [2 /*return*/, element];\n                }\n            });\n        });\n    };\n    /**\n     * Remove an element from the heap.\n     * @param  {any}   o      Element to be found\n     * @param  {Function} fn  Optional function to compare\n     * @return {Boolean}      True if the heap was modified\n     */\n    HeapAsync.prototype.remove = function (o, fn) {\n        if (fn === void 0) { fn = HeapAsync.defaultIsEqual; }\n        return __awaiter(this, void 0, void 0, function () {\n            var idx, i;\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(this.length > 0)) return [3 /*break*/, 13];\n                        if (!(o === undefined)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.pop()];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, true];\n                    case 2:\n                        idx = -1;\n                        i = 0;\n                        _a.label = 3;\n                    case 3:\n                        if (!(i < this.heapArray.length)) return [3 /*break*/, 6];\n                        return [4 /*yield*/, fn(this.heapArray[i], o)];\n                    case 4:\n                        if (_a.sent()) {\n                            idx = i;\n                            return [3 /*break*/, 6];\n                        }\n                        _a.label = 5;\n                    case 5:\n                        ++i;\n                        return [3 /*break*/, 3];\n                    case 6:\n                        if (!(idx >= 0)) return [3 /*break*/, 13];\n                        if (!(idx === 0)) return [3 /*break*/, 8];\n                        return [4 /*yield*/, this.pop()];\n                    case 7:\n                        _a.sent();\n                        return [3 /*break*/, 12];\n                    case 8:\n                        if (!(idx === this.length - 1)) return [3 /*break*/, 9];\n                        this.heapArray.pop();\n                        return [3 /*break*/, 12];\n                    case 9:\n                        this.heapArray.splice(idx, 1, this.heapArray.pop());\n                        return [4 /*yield*/, this._sortNodeUp(idx)];\n                    case 10:\n                        _a.sent();\n                        return [4 /*yield*/, this._sortNodeDown(idx)];\n                    case 11:\n                        _a.sent();\n                        _a.label = 12;\n                    case 12: return [2 /*return*/, true];\n                    case 13: return [2 /*return*/, false];\n                }\n            });\n        });\n    };\n    /**\n     * Pop the current peek value, and add the new item.\n     * @param  {any} element  Element to replace peek\n     * @return {any}         Old peek\n     */\n    HeapAsync.prototype.replace = function (element) {\n        return __awaiter(this, void 0, void 0, function () {\n            var peek;\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        peek = this.heapArray[0];\n                        this.heapArray[0] = element;\n                        return [4 /*yield*/, this._sortNodeDown(0)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, peek];\n                }\n            });\n        });\n    };\n    /**\n     * Size of the heap\n     * @return {Number}\n     */\n    HeapAsync.prototype.size = function () {\n        return this.length;\n    };\n    /**\n     * Return the top (highest value) N elements of the heap.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}    Array of length <= N.\n     */\n    HeapAsync.prototype.top = function (n) {\n        if (n === void 0) { n = 1; }\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator$1(this, function (_a) {\n                if (this.heapArray.length === 0 || n <= 0) {\n                    // Nothing to do\n                    return [2 /*return*/, []];\n                }\n                else if (this.heapArray.length === 1 || n === 1) {\n                    // Just the peek\n                    return [2 /*return*/, [this.heapArray[0]]];\n                }\n                else if (n >= this.heapArray.length) {\n                    // The whole peek\n                    return [2 /*return*/, __spreadArray$1([], __read$1(this.heapArray), false)];\n                }\n                else {\n                    // Some elements\n                    return [2 /*return*/, this._topN_push(~~n)];\n                }\n            });\n        });\n    };\n    /**\n     * Clone the heap's internal array\n     * @return {Array}\n     */\n    HeapAsync.prototype.toArray = function () {\n        return __spreadArray$1([], __read$1(this.heapArray), false);\n    };\n    /**\n     * String output, call to Array.prototype.toString()\n     * @return {String}\n     */\n    HeapAsync.prototype.toString = function () {\n        return this.heapArray.toString();\n    };\n    /**\n     * Get the element at the given index.\n     * @param  {Number} i Index to get\n     * @return {any}       Element at that index\n     */\n    HeapAsync.prototype.get = function (i) {\n        return this.heapArray[i];\n    };\n    /**\n     * Get the elements of these node's children\n     * @param  {Number} idx Node index\n     * @return {Array(any)}  Children elements\n     */\n    HeapAsync.prototype.getChildrenOf = function (idx) {\n        var _this = this;\n        return HeapAsync.getChildrenIndexOf(idx)\n            .map(function (i) { return _this.heapArray[i]; })\n            .filter(function (e) { return e !== undefined; });\n    };\n    /**\n     * Get the element of this node's parent\n     * @param  {Number} idx Node index\n     * @return {any}     Parent element\n     */\n    HeapAsync.prototype.getParentOf = function (idx) {\n        var pi = HeapAsync.getParentIndexOf(idx);\n        return this.heapArray[pi];\n    };\n    /**\n     * Iterator interface\n     */\n    HeapAsync.prototype[Symbol.iterator] = function () {\n        return __generator$1(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!this.length) return [3 /*break*/, 2];\n                    return [4 /*yield*/, this.pop()];\n                case 1:\n                    _a.sent();\n                    return [3 /*break*/, 0];\n                case 2: return [2 /*return*/];\n            }\n        });\n    };\n    /**\n     * Returns an iterator. To comply with Java interface.\n     */\n    HeapAsync.prototype.iterator = function () {\n        return this;\n    };\n    /**\n     * Limit heap size if needed\n     */\n    HeapAsync.prototype._applyLimit = function () {\n        if (this._limit && this._limit < this.heapArray.length) {\n            var rm = this.heapArray.length - this._limit;\n            // It's much faster than splice\n            while (rm) {\n                this.heapArray.pop();\n                --rm;\n            }\n        }\n    };\n    /**\n     * Return the bottom (lowest value) N elements of the heap, without corner cases, unsorted\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    HeapAsync.prototype._bottomN_push = function (n) {\n        return __awaiter(this, void 0, void 0, function () {\n            var bottomHeap, startAt, parentStartAt, indices, i, arr, i;\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        bottomHeap = new HeapAsync(this.compare);\n                        bottomHeap.limit = n;\n                        bottomHeap.heapArray = this.heapArray.slice(-n);\n                        return [4 /*yield*/, bottomHeap.init()];\n                    case 1:\n                        _a.sent();\n                        startAt = this.heapArray.length - 1 - n;\n                        parentStartAt = HeapAsync.getParentIndexOf(startAt);\n                        indices = [];\n                        for (i = startAt; i > parentStartAt; --i) {\n                            indices.push(i);\n                        }\n                        arr = this.heapArray;\n                        _a.label = 2;\n                    case 2:\n                        if (!indices.length) return [3 /*break*/, 6];\n                        i = indices.shift();\n                        return [4 /*yield*/, this.compare(arr[i], bottomHeap.peek())];\n                    case 3:\n                        if (!((_a.sent()) > 0)) return [3 /*break*/, 5];\n                        return [4 /*yield*/, bottomHeap.replace(arr[i])];\n                    case 4:\n                        _a.sent();\n                        if (i % 2) {\n                            indices.push(HeapAsync.getParentIndexOf(i));\n                        }\n                        _a.label = 5;\n                    case 5: return [3 /*break*/, 2];\n                    case 6: return [2 /*return*/, bottomHeap.toArray()];\n                }\n            });\n        });\n    };\n    /**\n     * Move a node to a new index, switching places\n     * @param  {Number} j First node index\n     * @param  {Number} k Another node index\n     */\n    HeapAsync.prototype._moveNode = function (j, k) {\n        var _a;\n        _a = __read$1([this.heapArray[k], this.heapArray[j]], 2), this.heapArray[j] = _a[0], this.heapArray[k] = _a[1];\n    };\n    /**\n     * Move a node down the tree (to the leaves) to find a place where the heap is sorted.\n     * @param  {Number} i Index of the node\n     */\n    HeapAsync.prototype._sortNodeDown = function (i) {\n        return __awaiter(this, void 0, void 0, function () {\n            var moveIt, self, getPotentialParent, childrenIdx, bestChildIndex, j, bestChild, _a;\n            var _this = this;\n            return __generator$1(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        moveIt = i < this.heapArray.length - 1;\n                        self = this.heapArray[i];\n                        getPotentialParent = function (best, j) { return __awaiter(_this, void 0, void 0, function () {\n                            var _a;\n                            return __generator$1(this, function (_b) {\n                                switch (_b.label) {\n                                    case 0:\n                                        _a = this.heapArray.length > j;\n                                        if (!_a) return [3 /*break*/, 2];\n                                        return [4 /*yield*/, this.compare(this.heapArray[j], this.heapArray[best])];\n                                    case 1:\n                                        _a = (_b.sent()) < 0;\n                                        _b.label = 2;\n                                    case 2:\n                                        if (_a) {\n                                            best = j;\n                                        }\n                                        return [2 /*return*/, best];\n                                }\n                            });\n                        }); };\n                        _b.label = 1;\n                    case 1:\n                        if (!moveIt) return [3 /*break*/, 8];\n                        childrenIdx = HeapAsync.getChildrenIndexOf(i);\n                        bestChildIndex = childrenIdx[0];\n                        j = 1;\n                        _b.label = 2;\n                    case 2:\n                        if (!(j < childrenIdx.length)) return [3 /*break*/, 5];\n                        return [4 /*yield*/, getPotentialParent(bestChildIndex, childrenIdx[j])];\n                    case 3:\n                        bestChildIndex = _b.sent();\n                        _b.label = 4;\n                    case 4:\n                        ++j;\n                        return [3 /*break*/, 2];\n                    case 5:\n                        bestChild = this.heapArray[bestChildIndex];\n                        _a = typeof bestChild !== 'undefined';\n                        if (!_a) return [3 /*break*/, 7];\n                        return [4 /*yield*/, this.compare(self, bestChild)];\n                    case 6:\n                        _a = (_b.sent()) > 0;\n                        _b.label = 7;\n                    case 7:\n                        if (_a) {\n                            this._moveNode(i, bestChildIndex);\n                            i = bestChildIndex;\n                        }\n                        else {\n                            moveIt = false;\n                        }\n                        return [3 /*break*/, 1];\n                    case 8: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Move a node up the tree (to the root) to find a place where the heap is sorted.\n     * @param  {Number} i Index of the node\n     */\n    HeapAsync.prototype._sortNodeUp = function (i) {\n        return __awaiter(this, void 0, void 0, function () {\n            var moveIt, pi, _a;\n            return __generator$1(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        moveIt = i > 0;\n                        _b.label = 1;\n                    case 1:\n                        if (!moveIt) return [3 /*break*/, 4];\n                        pi = HeapAsync.getParentIndexOf(i);\n                        _a = pi >= 0;\n                        if (!_a) return [3 /*break*/, 3];\n                        return [4 /*yield*/, this.compare(this.heapArray[pi], this.heapArray[i])];\n                    case 2:\n                        _a = (_b.sent()) > 0;\n                        _b.label = 3;\n                    case 3:\n                        if (_a) {\n                            this._moveNode(i, pi);\n                            i = pi;\n                        }\n                        else {\n                            moveIt = false;\n                        }\n                        return [3 /*break*/, 1];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n     * Implementation: push.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    HeapAsync.prototype._topN_push = function (n) {\n        return __awaiter(this, void 0, void 0, function () {\n            var topHeap, indices, arr, i;\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        topHeap = new HeapAsync(this._invertedCompare);\n                        topHeap.limit = n;\n                        indices = [0];\n                        arr = this.heapArray;\n                        _a.label = 1;\n                    case 1:\n                        if (!indices.length) return [3 /*break*/, 7];\n                        i = indices.shift();\n                        if (!(i < arr.length)) return [3 /*break*/, 6];\n                        if (!(topHeap.length < n)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, topHeap.push(arr[i])];\n                    case 2:\n                        _a.sent();\n                        indices.push.apply(indices, __spreadArray$1([], __read$1(HeapAsync.getChildrenIndexOf(i)), false));\n                        return [3 /*break*/, 6];\n                    case 3: return [4 /*yield*/, this.compare(arr[i], topHeap.peek())];\n                    case 4:\n                        if (!((_a.sent()) < 0)) return [3 /*break*/, 6];\n                        return [4 /*yield*/, topHeap.replace(arr[i])];\n                    case 5:\n                        _a.sent();\n                        indices.push.apply(indices, __spreadArray$1([], __read$1(HeapAsync.getChildrenIndexOf(i)), false));\n                        _a.label = 6;\n                    case 6: return [3 /*break*/, 1];\n                    case 7: return [2 /*return*/, topHeap.toArray()];\n                }\n            });\n        });\n    };\n    /**\n     * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n     * Implementation: init + push.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    HeapAsync.prototype._topN_fill = function (n) {\n        return __awaiter(this, void 0, void 0, function () {\n            var heapArray, topHeap, branch, indices, i, i;\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        heapArray = this.heapArray;\n                        topHeap = new HeapAsync(this._invertedCompare);\n                        topHeap.limit = n;\n                        topHeap.heapArray = heapArray.slice(0, n);\n                        return [4 /*yield*/, topHeap.init()];\n                    case 1:\n                        _a.sent();\n                        branch = HeapAsync.getParentIndexOf(n - 1) + 1;\n                        indices = [];\n                        for (i = branch; i < n; ++i) {\n                            indices.push.apply(indices, __spreadArray$1([], __read$1(HeapAsync.getChildrenIndexOf(i).filter(function (l) { return l < heapArray.length; })), false));\n                        }\n                        if ((n - 1) % 2) {\n                            indices.push(n);\n                        }\n                        _a.label = 2;\n                    case 2:\n                        if (!indices.length) return [3 /*break*/, 6];\n                        i = indices.shift();\n                        if (!(i < heapArray.length)) return [3 /*break*/, 5];\n                        return [4 /*yield*/, this.compare(heapArray[i], topHeap.peek())];\n                    case 3:\n                        if (!((_a.sent()) < 0)) return [3 /*break*/, 5];\n                        return [4 /*yield*/, topHeap.replace(heapArray[i])];\n                    case 4:\n                        _a.sent();\n                        indices.push.apply(indices, __spreadArray$1([], __read$1(HeapAsync.getChildrenIndexOf(i)), false));\n                        _a.label = 5;\n                    case 5: return [3 /*break*/, 2];\n                    case 6: return [2 /*return*/, topHeap.toArray()];\n                }\n            });\n        });\n    };\n    /**\n     * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n     * Implementation: heap.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    HeapAsync.prototype._topN_heap = function (n) {\n        return __awaiter(this, void 0, void 0, function () {\n            var topHeap, result, i, _a, _b;\n            return __generator$1(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        topHeap = this.clone();\n                        result = [];\n                        i = 0;\n                        _c.label = 1;\n                    case 1:\n                        if (!(i < n)) return [3 /*break*/, 4];\n                        _b = (_a = result).push;\n                        return [4 /*yield*/, topHeap.pop()];\n                    case 2:\n                        _b.apply(_a, [(_c.sent())]);\n                        _c.label = 3;\n                    case 3:\n                        ++i;\n                        return [3 /*break*/, 1];\n                    case 4: return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    /**\n     * Return index of the top element\n     * @param list\n     */\n    HeapAsync.prototype._topIdxOf = function (list) {\n        return __awaiter(this, void 0, void 0, function () {\n            var idx, top, i, comp;\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!list.length) {\n                            return [2 /*return*/, -1];\n                        }\n                        idx = 0;\n                        top = list[idx];\n                        i = 1;\n                        _a.label = 1;\n                    case 1:\n                        if (!(i < list.length)) return [3 /*break*/, 4];\n                        return [4 /*yield*/, this.compare(list[i], top)];\n                    case 2:\n                        comp = _a.sent();\n                        if (comp < 0) {\n                            idx = i;\n                            top = list[i];\n                        }\n                        _a.label = 3;\n                    case 3:\n                        ++i;\n                        return [3 /*break*/, 1];\n                    case 4: return [2 /*return*/, idx];\n                }\n            });\n        });\n    };\n    /**\n     * Return the top element\n     * @param list\n     */\n    HeapAsync.prototype._topOf = function () {\n        var list = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            list[_i] = arguments[_i];\n        }\n        return __awaiter(this, void 0, void 0, function () {\n            var heap;\n            return __generator$1(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        heap = new HeapAsync(this.compare);\n                        return [4 /*yield*/, heap.init(list)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, heap.peek()];\n                }\n            });\n        });\n    };\n    return HeapAsync;\n}());\n\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar toInt = function (n) { return ~~n; };\n/**\n * Heap\n * @type {Class}\n */\nvar Heap = /** @class */ (function () {\n    /**\n     * Heap instance constructor.\n     * @param  {Function} compare Optional comparison function, defaults to Heap.minComparator<number>\n     */\n    function Heap(compare) {\n        if (compare === void 0) { compare = Heap.minComparator; }\n        var _this = this;\n        this.compare = compare;\n        this.heapArray = [];\n        this._limit = 0;\n        /**\n         * Alias of add\n         */\n        this.offer = this.add;\n        /**\n         * Alias of peek\n         */\n        this.element = this.peek;\n        /**\n         * Alias of pop\n         */\n        this.poll = this.pop;\n        /**\n         * Returns the inverse to the comparison function.\n         * @return {Function}\n         */\n        this._invertedCompare = function (a, b) {\n            return -1 * _this.compare(a, b);\n        };\n    }\n    /*\n              Static methods\n     */\n    /**\n     * Gets children indices for given index.\n     * @param  {Number} idx     Parent index\n     * @return {Array(Number)}  Array of children indices\n     */\n    Heap.getChildrenIndexOf = function (idx) {\n        return [idx * 2 + 1, idx * 2 + 2];\n    };\n    /**\n     * Gets parent index for given index.\n     * @param  {Number} idx  Children index\n     * @return {Number | undefined}      Parent index, -1 if idx is 0\n     */\n    Heap.getParentIndexOf = function (idx) {\n        if (idx <= 0) {\n            return -1;\n        }\n        var whichChildren = idx % 2 ? 1 : 2;\n        return Math.floor((idx - whichChildren) / 2);\n    };\n    /**\n     * Gets sibling index for given index.\n     * @param  {Number} idx  Children index\n     * @return {Number | undefined}      Sibling index, -1 if idx is 0\n     */\n    Heap.getSiblingIndexOf = function (idx) {\n        if (idx <= 0) {\n            return -1;\n        }\n        var whichChildren = idx % 2 ? 1 : -1;\n        return idx + whichChildren;\n    };\n    /**\n     * Min heap comparison function, default.\n     * @param  {any} a     First element\n     * @param  {any} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    Heap.minComparator = function (a, b) {\n        if (a > b) {\n            return 1;\n        }\n        else if (a < b) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    };\n    /**\n     * Max heap comparison function.\n     * @param  {any} a     First element\n     * @param  {any} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    Heap.maxComparator = function (a, b) {\n        if (b > a) {\n            return 1;\n        }\n        else if (b < a) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    };\n    /**\n     * Min number heap comparison function, default.\n     * @param  {Number} a     First element\n     * @param  {Number} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    Heap.minComparatorNumber = function (a, b) {\n        return a - b;\n    };\n    /**\n     * Max number heap comparison function.\n     * @param  {Number} a     First element\n     * @param  {Number} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    Heap.maxComparatorNumber = function (a, b) {\n        return b - a;\n    };\n    /**\n     * Default equality function.\n     * @param  {any} a    First element\n     * @param  {any} b    Second element\n     * @return {Boolean}  True if equal, false otherwise\n     */\n    Heap.defaultIsEqual = function (a, b) {\n        return a === b;\n    };\n    /**\n     * Prints a heap.\n     * @param  {Heap} heap Heap to be printed\n     * @returns {String}\n     */\n    Heap.print = function (heap) {\n        function deep(i) {\n            var pi = Heap.getParentIndexOf(i);\n            return Math.floor(Math.log2(pi + 1));\n        }\n        function repeat(str, times) {\n            var out = '';\n            for (; times > 0; --times) {\n                out += str;\n            }\n            return out;\n        }\n        var node = 0;\n        var lines = [];\n        var maxLines = deep(heap.length - 1) + 2;\n        var maxLength = 0;\n        while (node < heap.length) {\n            var i = deep(node) + 1;\n            if (node === 0) {\n                i = 0;\n            }\n            // Text representation\n            var nodeText = String(heap.get(node));\n            if (nodeText.length > maxLength) {\n                maxLength = nodeText.length;\n            }\n            // Add to line\n            lines[i] = lines[i] || [];\n            lines[i].push(nodeText);\n            node += 1;\n        }\n        return lines\n            .map(function (line, i) {\n            var times = Math.pow(2, maxLines - i) - 1;\n            return (repeat(' ', Math.floor(times / 2) * maxLength) +\n                line\n                    .map(function (el) {\n                    // centered\n                    var half = (maxLength - el.length) / 2;\n                    return repeat(' ', Math.ceil(half)) + el + repeat(' ', Math.floor(half));\n                })\n                    .join(repeat(' ', times * maxLength)));\n        })\n            .join('\\n');\n    };\n    /*\n              Python style\n     */\n    /**\n     * Converts an array into an array-heap, in place\n     * @param  {Array}    arr      Array to be modified\n     * @param  {Function} compare  Optional compare function\n     * @return {Heap}              For convenience, it returns a Heap instance\n     */\n    Heap.heapify = function (arr, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = arr;\n        heap.init();\n        return heap;\n    };\n    /**\n     * Extract the peek of an array-heap\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Returns the extracted peek\n     */\n    Heap.heappop = function (heapArr, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.pop();\n    };\n    /**\n     * Pushes a item into an array-heap\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {any}      item     Item to push\n     * @param  {Function} compare  Optional compare function\n     */\n    Heap.heappush = function (heapArr, item, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        heap.push(item);\n    };\n    /**\n     * Push followed by pop, faster\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {any}      item     Item to push\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Returns the extracted peek\n     */\n    Heap.heappushpop = function (heapArr, item, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.pushpop(item);\n    };\n    /**\n     * Replace peek with item\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {any}      item     Item as replacement\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Returns the extracted peek\n     */\n    Heap.heapreplace = function (heapArr, item, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.replace(item);\n    };\n    /**\n     * Return the `n` most valuable elements of a heap-like Array\n     * @param  {Array}    heapArr  Array, should be an array-heap\n     * @param  {number}   n        Max number of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    Heap.heaptop = function (heapArr, n, compare) {\n        if (n === void 0) { n = 1; }\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.top(n);\n    };\n    /**\n     * Return the `n` least valuable elements of a heap-like Array\n     * @param  {Array}    heapArr  Array, should be an array-heap\n     * @param  {number}   n        Max number of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    Heap.heapbottom = function (heapArr, n, compare) {\n        if (n === void 0) { n = 1; }\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.bottom(n);\n    };\n    /**\n     * Return the `n` most valuable elements of an iterable\n     * @param  {number}   n        Max number of elements\n     * @param  {Iterable} Iterable Iterable list of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    Heap.nlargest = function (n, iterable, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = __spreadArray([], __read(iterable), false);\n        heap.init();\n        return heap.top(n);\n    };\n    /**\n     * Return the `n` least valuable elements of an iterable\n     * @param  {number}   n        Max number of elements\n     * @param  {Iterable} Iterable Iterable list of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    Heap.nsmallest = function (n, iterable, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = __spreadArray([], __read(iterable), false);\n        heap.init();\n        return heap.bottom(n);\n    };\n    /*\n              Instance methods\n     */\n    /**\n     * Adds an element to the heap. Aliases: `offer`.\n     * Same as: push(element)\n     * @param {any} element Element to be added\n     * @return {Boolean} true\n     */\n    Heap.prototype.add = function (element) {\n        this._sortNodeUp(this.heapArray.push(element) - 1);\n        this._applyLimit();\n        return true;\n    };\n    /**\n     * Adds an array of elements to the heap.\n     * Similar as: push(element, element, ...).\n     * @param {Array} elements Elements to be added\n     * @return {Boolean} true\n     */\n    Heap.prototype.addAll = function (elements) {\n        var _a;\n        var i = this.length;\n        (_a = this.heapArray).push.apply(_a, __spreadArray([], __read(elements), false));\n        for (var l = this.length; i < l; ++i) {\n            this._sortNodeUp(i);\n        }\n        this._applyLimit();\n        return true;\n    };\n    /**\n     * Return the bottom (lowest value) N elements of the heap.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype.bottom = function (n) {\n        if (n === void 0) { n = 1; }\n        if (this.heapArray.length === 0 || n <= 0) {\n            // Nothing to do\n            return [];\n        }\n        else if (this.heapArray.length === 1) {\n            // Just the peek\n            return [this.heapArray[0]];\n        }\n        else if (n >= this.heapArray.length) {\n            // The whole heap\n            return __spreadArray([], __read(this.heapArray), false);\n        }\n        else {\n            // Some elements\n            return this._bottomN_push(~~n);\n        }\n    };\n    /**\n     * Check if the heap is sorted, useful for testing purposes.\n     * @return {Undefined | Element}  Returns an element if something wrong is found, otherwise it's undefined\n     */\n    Heap.prototype.check = function () {\n        var _this = this;\n        return this.heapArray.find(function (el, j) { return !!_this.getChildrenOf(j).find(function (ch) { return _this.compare(el, ch) > 0; }); });\n    };\n    /**\n     * Remove all of the elements from this heap.\n     */\n    Heap.prototype.clear = function () {\n        this.heapArray = [];\n    };\n    /**\n     * Clone this heap\n     * @return {Heap}\n     */\n    Heap.prototype.clone = function () {\n        var cloned = new Heap(this.comparator());\n        cloned.heapArray = this.toArray();\n        cloned._limit = this._limit;\n        return cloned;\n    };\n    /**\n     * Returns the comparison function.\n     * @return {Function}\n     */\n    Heap.prototype.comparator = function () {\n        return this.compare;\n    };\n    /**\n     * Returns true if this queue contains the specified element.\n     * @param  {any}      o   Element to be found\n     * @param  {Function} fn  Optional comparison function, receives (element, needle)\n     * @return {Boolean}\n     */\n    Heap.prototype.contains = function (o, fn) {\n        if (fn === void 0) { fn = Heap.defaultIsEqual; }\n        return this.heapArray.findIndex(function (el) { return fn(el, o); }) >= 0;\n    };\n    /**\n     * Initialise a heap, sorting nodes\n     * @param  {Array} array Optional initial state array\n     */\n    Heap.prototype.init = function (array) {\n        if (array) {\n            this.heapArray = __spreadArray([], __read(array), false);\n        }\n        for (var i = Math.floor(this.heapArray.length); i >= 0; --i) {\n            this._sortNodeDown(i);\n        }\n        this._applyLimit();\n    };\n    /**\n     * Test if the heap has no elements.\n     * @return {Boolean} True if no elements on the heap\n     */\n    Heap.prototype.isEmpty = function () {\n        return this.length === 0;\n    };\n    /**\n     * Get the leafs of the tree (no children nodes)\n     */\n    Heap.prototype.leafs = function () {\n        if (this.heapArray.length === 0) {\n            return [];\n        }\n        var pi = Heap.getParentIndexOf(this.heapArray.length - 1);\n        return this.heapArray.slice(pi + 1);\n    };\n    Object.defineProperty(Heap.prototype, \"length\", {\n        /**\n         * Length of the heap.\n         * @return {Number}\n         */\n        get: function () {\n            return this.heapArray.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Heap.prototype, \"limit\", {\n        /**\n         * Get length limit of the heap.\n         * @return {Number}\n         */\n        get: function () {\n            return this._limit;\n        },\n        /**\n         * Set length limit of the heap.\n         * @return {Number}\n         */\n        set: function (_l) {\n            this._limit = ~~_l;\n            this._applyLimit();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Top node. Aliases: `element`.\n     * Same as: `top(1)[0]`\n     * @return {any} Top node\n     */\n    Heap.prototype.peek = function () {\n        return this.heapArray[0];\n    };\n    /**\n     * Extract the top node (root). Aliases: `poll`.\n     * @return {any} Extracted top node, undefined if empty\n     */\n    Heap.prototype.pop = function () {\n        var last = this.heapArray.pop();\n        if (this.length > 0 && last !== undefined) {\n            return this.replace(last);\n        }\n        return last;\n    };\n    /**\n     * Pushes element(s) to the heap.\n     * @param  {...any} elements Elements to insert\n     * @return {Boolean} True if elements are present\n     */\n    Heap.prototype.push = function () {\n        var elements = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            elements[_i] = arguments[_i];\n        }\n        if (elements.length < 1) {\n            return false;\n        }\n        else if (elements.length === 1) {\n            return this.add(elements[0]);\n        }\n        else {\n            return this.addAll(elements);\n        }\n    };\n    /**\n     * Same as push & pop in sequence, but faster\n     * @param  {any} element Element to insert\n     * @return {any}  Extracted top node\n     */\n    Heap.prototype.pushpop = function (element) {\n        var _a;\n        if (this.compare(this.heapArray[0], element) < 0) {\n            _a = __read([this.heapArray[0], element], 2), element = _a[0], this.heapArray[0] = _a[1];\n            this._sortNodeDown(0);\n        }\n        return element;\n    };\n    /**\n     * Remove an element from the heap.\n     * @param  {any}   o      Element to be found\n     * @param  {Function} fn  Optional function to compare\n     * @return {Boolean}      True if the heap was modified\n     */\n    Heap.prototype.remove = function (o, fn) {\n        if (fn === void 0) { fn = Heap.defaultIsEqual; }\n        if (this.length > 0) {\n            if (o === undefined) {\n                this.pop();\n                return true;\n            }\n            else {\n                var idx = this.heapArray.findIndex(function (el) { return fn(el, o); });\n                if (idx >= 0) {\n                    if (idx === 0) {\n                        this.pop();\n                    }\n                    else if (idx === this.length - 1) {\n                        this.heapArray.pop();\n                    }\n                    else {\n                        this.heapArray.splice(idx, 1, this.heapArray.pop());\n                        this._sortNodeUp(idx);\n                        this._sortNodeDown(idx);\n                    }\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    /**\n     * Pop the current peek value, and add the new item.\n     * @param  {any} element  Element to replace peek\n     * @return {any}         Old peek\n     */\n    Heap.prototype.replace = function (element) {\n        var peek = this.heapArray[0];\n        this.heapArray[0] = element;\n        this._sortNodeDown(0);\n        return peek;\n    };\n    /**\n     * Size of the heap\n     * @return {Number}\n     */\n    Heap.prototype.size = function () {\n        return this.length;\n    };\n    /**\n     * Return the top (highest value) N elements of the heap.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}    Array of length <= N.\n     */\n    Heap.prototype.top = function (n) {\n        if (n === void 0) { n = 1; }\n        if (this.heapArray.length === 0 || n <= 0) {\n            // Nothing to do\n            return [];\n        }\n        else if (this.heapArray.length === 1 || n === 1) {\n            // Just the peek\n            return [this.heapArray[0]];\n        }\n        else if (n >= this.heapArray.length) {\n            // The whole peek\n            return __spreadArray([], __read(this.heapArray), false);\n        }\n        else {\n            // Some elements\n            return this._topN_push(~~n);\n        }\n    };\n    /**\n     * Clone the heap's internal array\n     * @return {Array}\n     */\n    Heap.prototype.toArray = function () {\n        return __spreadArray([], __read(this.heapArray), false);\n    };\n    /**\n     * String output, call to Array.prototype.toString()\n     * @return {String}\n     */\n    Heap.prototype.toString = function () {\n        return this.heapArray.toString();\n    };\n    /**\n     * Get the element at the given index.\n     * @param  {Number} i Index to get\n     * @return {any}       Element at that index\n     */\n    Heap.prototype.get = function (i) {\n        return this.heapArray[i];\n    };\n    /**\n     * Get the elements of these node's children\n     * @param  {Number} idx Node index\n     * @return {Array(any)}  Children elements\n     */\n    Heap.prototype.getChildrenOf = function (idx) {\n        var _this = this;\n        return Heap.getChildrenIndexOf(idx)\n            .map(function (i) { return _this.heapArray[i]; })\n            .filter(function (e) { return e !== undefined; });\n    };\n    /**\n     * Get the element of this node's parent\n     * @param  {Number} idx Node index\n     * @return {any}     Parent element\n     */\n    Heap.prototype.getParentOf = function (idx) {\n        var pi = Heap.getParentIndexOf(idx);\n        return this.heapArray[pi];\n    };\n    /**\n     * Iterator interface\n     */\n    Heap.prototype[Symbol.iterator] = function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!this.length) return [3 /*break*/, 2];\n                    return [4 /*yield*/, this.pop()];\n                case 1:\n                    _a.sent();\n                    return [3 /*break*/, 0];\n                case 2: return [2 /*return*/];\n            }\n        });\n    };\n    /**\n     * Returns an iterator. To comply with Java interface.\n     */\n    Heap.prototype.iterator = function () {\n        return this.toArray();\n    };\n    /**\n     * Limit heap size if needed\n     */\n    Heap.prototype._applyLimit = function () {\n        if (this._limit && this._limit < this.heapArray.length) {\n            var rm = this.heapArray.length - this._limit;\n            // It's much faster than splice\n            while (rm) {\n                this.heapArray.pop();\n                --rm;\n            }\n        }\n    };\n    /**\n     * Return the bottom (lowest value) N elements of the heap, without corner cases, unsorted\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype._bottomN_push = function (n) {\n        // Use an inverted heap\n        var bottomHeap = new Heap(this.compare);\n        bottomHeap.limit = n;\n        bottomHeap.heapArray = this.heapArray.slice(-n);\n        bottomHeap.init();\n        var startAt = this.heapArray.length - 1 - n;\n        var parentStartAt = Heap.getParentIndexOf(startAt);\n        var indices = [];\n        for (var i = startAt; i > parentStartAt; --i) {\n            indices.push(i);\n        }\n        var arr = this.heapArray;\n        while (indices.length) {\n            var i = indices.shift();\n            if (this.compare(arr[i], bottomHeap.peek()) > 0) {\n                bottomHeap.replace(arr[i]);\n                if (i % 2) {\n                    indices.push(Heap.getParentIndexOf(i));\n                }\n            }\n        }\n        return bottomHeap.toArray();\n    };\n    /**\n     * Move a node to a new index, switching places\n     * @param  {Number} j First node index\n     * @param  {Number} k Another node index\n     */\n    Heap.prototype._moveNode = function (j, k) {\n        var _a;\n        _a = __read([this.heapArray[k], this.heapArray[j]], 2), this.heapArray[j] = _a[0], this.heapArray[k] = _a[1];\n    };\n    /**\n     * Move a node down the tree (to the leaves) to find a place where the heap is sorted.\n     * @param  {Number} i Index of the node\n     */\n    Heap.prototype._sortNodeDown = function (i) {\n        var _this = this;\n        var moveIt = i < this.heapArray.length - 1;\n        var self = this.heapArray[i];\n        var getPotentialParent = function (best, j) {\n            if (_this.heapArray.length > j && _this.compare(_this.heapArray[j], _this.heapArray[best]) < 0) {\n                best = j;\n            }\n            return best;\n        };\n        while (moveIt) {\n            var childrenIdx = Heap.getChildrenIndexOf(i);\n            var bestChildIndex = childrenIdx.reduce(getPotentialParent, childrenIdx[0]);\n            var bestChild = this.heapArray[bestChildIndex];\n            if (typeof bestChild !== 'undefined' && this.compare(self, bestChild) > 0) {\n                this._moveNode(i, bestChildIndex);\n                i = bestChildIndex;\n            }\n            else {\n                moveIt = false;\n            }\n        }\n    };\n    /**\n     * Move a node up the tree (to the root) to find a place where the heap is sorted.\n     * @param  {Number} i Index of the node\n     */\n    Heap.prototype._sortNodeUp = function (i) {\n        var moveIt = i > 0;\n        while (moveIt) {\n            var pi = Heap.getParentIndexOf(i);\n            if (pi >= 0 && this.compare(this.heapArray[pi], this.heapArray[i]) > 0) {\n                this._moveNode(i, pi);\n                i = pi;\n            }\n            else {\n                moveIt = false;\n            }\n        }\n    };\n    /**\n     * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n     * Implementation: push.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype._topN_push = function (n) {\n        // Use an inverted heap\n        var topHeap = new Heap(this._invertedCompare);\n        topHeap.limit = n;\n        var indices = [0];\n        var arr = this.heapArray;\n        while (indices.length) {\n            var i = indices.shift();\n            if (i < arr.length) {\n                if (topHeap.length < n) {\n                    topHeap.push(arr[i]);\n                    indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i)), false));\n                }\n                else if (this.compare(arr[i], topHeap.peek()) < 0) {\n                    topHeap.replace(arr[i]);\n                    indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i)), false));\n                }\n            }\n        }\n        return topHeap.toArray();\n    };\n    /**\n     * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n     * Implementation: init + push.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype._topN_fill = function (n) {\n        // Use an inverted heap\n        var heapArray = this.heapArray;\n        var topHeap = new Heap(this._invertedCompare);\n        topHeap.limit = n;\n        topHeap.heapArray = heapArray.slice(0, n);\n        topHeap.init();\n        var branch = Heap.getParentIndexOf(n - 1) + 1;\n        var indices = [];\n        for (var i = branch; i < n; ++i) {\n            indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i).filter(function (l) { return l < heapArray.length; })), false));\n        }\n        if ((n - 1) % 2) {\n            indices.push(n);\n        }\n        while (indices.length) {\n            var i = indices.shift();\n            if (i < heapArray.length) {\n                if (this.compare(heapArray[i], topHeap.peek()) < 0) {\n                    topHeap.replace(heapArray[i]);\n                    indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i)), false));\n                }\n            }\n        }\n        return topHeap.toArray();\n    };\n    /**\n     * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n     * Implementation: heap.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype._topN_heap = function (n) {\n        var topHeap = this.clone();\n        var result = [];\n        for (var i = 0; i < n; ++i) {\n            result.push(topHeap.pop());\n        }\n        return result;\n    };\n    /**\n     * Return index of the top element\n     * @param list\n     */\n    Heap.prototype._topIdxOf = function (list) {\n        if (!list.length) {\n            return -1;\n        }\n        var idx = 0;\n        var top = list[idx];\n        for (var i = 1; i < list.length; ++i) {\n            var comp = this.compare(list[i], top);\n            if (comp < 0) {\n                idx = i;\n                top = list[i];\n            }\n        }\n        return idx;\n    };\n    /**\n     * Return the top element\n     * @param list\n     */\n    Heap.prototype._topOf = function () {\n        var list = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            list[_i] = arguments[_i];\n        }\n        var heap = new Heap(this.compare);\n        heap.init(list);\n        return heap.peek();\n    };\n    return Heap;\n}());\n\nexport { Heap, HeapAsync, Heap as default, toInt };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}