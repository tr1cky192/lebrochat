{"ast":null,"code":"\"use strict\";\n\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OrderedQueue = exports.Queue = exports.MessageQueue = void 0;\nconst events_1 = require(\"events\");\nconst message_batch_1 = require(\"./message-batch\");\nconst publish_error_1 = require(\"./publish-error\");\nconst util_1 = require(\"util\");\n/**\n * Queues are used to manage publishing batches of messages.\n *\n * @private\n *\n * @param {Publisher} publisher The parent publisher.\n */\nclass MessageQueue extends events_1.EventEmitter {\n  constructor(publisher) {\n    super();\n    this.publisher = publisher;\n    this.batchOptions = publisher.settings.batching;\n  }\n  /**\n   * Forces the queue to update its options from the publisher.\n   * The specific queue will need to do a bit more to pass the new\n   * values down into any MessageBatch.\n   *\n   * This is only for use by {@link Publisher}.\n   *\n   * @private\n   */\n  updateOptions() {\n    this.batchOptions = this.publisher.settings.batching;\n  }\n  /**\n   * Accepts a batch of messages and publishes them to the API.\n   *\n   * @param {object[]} messages The messages to publish.\n   * @param {PublishCallback[]} callbacks The corresponding callback functions.\n   */\n  async _publish(messages, callbacks) {\n    const {\n      topic,\n      settings\n    } = this.publisher;\n    const reqOpts = {\n      topic: topic.name,\n      messages\n    };\n    if (messages.length === 0) {\n      return;\n    }\n    const requestCallback = topic.request;\n    const request = (0, util_1.promisify)(requestCallback.bind(topic));\n    try {\n      const resp = await request({\n        client: 'PublisherClient',\n        method: 'publish',\n        reqOpts,\n        gaxOpts: settings.gaxOpts\n      });\n      if (resp) {\n        const messageIds = resp.messageIds || [];\n        callbacks.forEach((callback, i) => callback(null, messageIds[i]));\n      }\n    } catch (e) {\n      const err = e;\n      callbacks.forEach(callback => callback(err));\n      throw e;\n    }\n  }\n}\nexports.MessageQueue = MessageQueue;\n/**\n * Standard message queue used for publishing messages.\n *\n * @private\n * @extends MessageQueue\n *\n * @param {Publisher} publisher The publisher.\n */\nclass Queue extends MessageQueue {\n  constructor(publisher) {\n    super(publisher);\n    this.batch = new message_batch_1.MessageBatch(this.batchOptions);\n  }\n  // This needs to update our existing message batch.\n  updateOptions() {\n    super.updateOptions();\n    this.batch.setOptions(this.batchOptions);\n  }\n  /**\n   * Adds a message to the queue.\n   *\n   * @param {PubsubMessage} message The message to publish.\n   * @param {PublishCallback} callback The publish callback.\n   */\n  add(message, callback) {\n    if (!this.batch.canFit(message)) {\n      // Make a background best-effort attempt to clear out the\n      // queue. If this fails, we'll basically just be overloaded\n      // for a bit.\n      this.publish().catch(() => {});\n    }\n    this.batch.add(message, callback);\n    if (this.batch.isFull()) {\n      // See comment above - best effort.\n      this.publish().catch(() => {});\n    } else if (!this.pending) {\n      const {\n        maxMilliseconds\n      } = this.batchOptions;\n      this.pending = setTimeout(() => {\n        // See comment above - we are basically making a best effort\n        // to start clearing out the queue if nothing else happens\n        // before the batch timeout.\n        this.publish().catch(() => {});\n      }, maxMilliseconds);\n    }\n  }\n  /**\n   * Cancels any pending publishes and calls _publish immediately.\n   *\n   * _Does_ attempt to further drain after one batch is sent.\n   *\n   * @emits Queue#drain when all messages are sent.\n   */\n  async publishDrain() {\n    await this._publishInternal(true);\n  }\n  /**\n   * Cancels any pending publishes and calls _publish immediately.\n   *\n   * Does _not_ attempt to further drain after one batch is sent.\n   */\n  async publish() {\n    await this._publishInternal(false);\n  }\n  /**\n   * Cancels any pending publishes and calls _publish immediately.\n   *\n   * @emits Queue#drain when all messages are sent.\n   */\n  async _publishInternal(fullyDrain) {\n    const {\n      messages,\n      callbacks\n    } = this.batch;\n    this.batch = new message_batch_1.MessageBatch(this.batchOptions);\n    if (this.pending) {\n      clearTimeout(this.pending);\n      delete this.pending;\n    }\n    await this._publish(messages, callbacks);\n    if (this.batch.messages.length) {\n      // We only do the indefinite go-arounds when we're trying to do a\n      // final drain for flush(). In all other cases, we want to leave\n      // subsequent batches alone so that they can time out as needed.\n      if (fullyDrain) {\n        await this._publishInternal(true);\n      }\n    } else {\n      this.emit('drain');\n    }\n  }\n}\nexports.Queue = Queue;\n/**\n * Queue for handling ordered messages. Unlike the standard queue, this\n * ensures that batches are published one at a time and throws an exception in\n * the event that any batch fails to publish.\n *\n * @private\n * @extends MessageQueue\n *\n * @param {Publisher} publisher The publisher.\n * @param {string} key The key used to order the messages.\n */\nclass OrderedQueue extends MessageQueue {\n  constructor(publisher, key) {\n    super(publisher);\n    this.batches = [];\n    this.inFlight = false;\n    this.key = key;\n  }\n  // This needs to update our existing message batches.\n  updateOptions() {\n    super.updateOptions();\n    this.batches.forEach(b => b.setOptions(this.batchOptions));\n  }\n  /**\n   * Reference to the batch we're currently filling.\n   * @returns {MessageBatch}\n   */\n  get currentBatch() {\n    if (!this.batches.length) {\n      this.batches.push(this.createBatch());\n    }\n    return this.batches[0];\n  }\n  /**\n   * Adds a message to a batch, creating a new batch if need be.\n   *\n   * @param {object} message The message to publish.\n   * @param {PublishCallback} callback The publish callback.\n   */\n  add(message, callback) {\n    if (this.error) {\n      callback(this.error);\n      return;\n    }\n    if (this.inFlight) {\n      // in the event that a batch is currently in flight, we can overfill\n      // the next batch as long as it hasn't hit the API limit\n      if (this.currentBatch.isAtMax()) {\n        this.batches.unshift(this.createBatch());\n      }\n      this.currentBatch.add(message, callback);\n      return;\n    }\n    if (!this.currentBatch.canFit(message)) {\n      // Make a best-effort attempt to clear out the publish queue,\n      // to make more space for the new batch. If this fails, we'll\n      // just be overfilled for a bit.\n      this.publish().catch(() => {});\n    }\n    this.currentBatch.add(message, callback);\n    // it is possible that we triggered a publish earlier, so we'll need to\n    // check again here\n    if (!this.inFlight) {\n      if (this.currentBatch.isFull()) {\n        // See comment above - best-effort.\n        this.publish().catch(() => {});\n      } else if (!this.pending) {\n        this.beginNextPublish();\n      }\n    }\n  }\n  /**\n   * Starts a timeout to publish any pending messages.\n   */\n  beginNextPublish() {\n    const maxMilliseconds = this.batchOptions.maxMilliseconds;\n    const timeWaiting = Date.now() - this.currentBatch.created;\n    const delay = Math.max(0, maxMilliseconds - timeWaiting);\n    this.pending = setTimeout(() => {\n      // Make a best-effort attempt to start a publish request. If\n      // this fails, we'll catch it again later, eventually, when more\n      // messages try to enter the queue.\n      this.publish().catch(() => {});\n    }, delay);\n  }\n  /**\n   * Creates a new {@link MessageBatch} instance.\n   *\n   * @returns {MessageBatch}\n   */\n  createBatch() {\n    return new message_batch_1.MessageBatch(this.batchOptions);\n  }\n  /**\n   * In the event of a publish failure, we need to cache the error in question\n   * and reject all pending publish calls, prompting the user to call\n   * {@link OrderedQueue#resumePublishing}.\n   *\n   * @param {Error} err The publishing error.\n   */\n  handlePublishFailure(err) {\n    this.error = new publish_error_1.PublishError(this.key, err);\n    // reject all pending publishes\n    while (this.batches.length) {\n      const {\n        callbacks\n      } = this.batches.pop();\n      callbacks.forEach(callback => callback(err));\n    }\n  }\n  /**\n   * Publishes the messages. If successful it will prepare the next batch to be\n   * published immediately after. If an error occurs, it will reject all\n   * pending messages. In the event that no pending messages/batches are left,\n   * a \"drain\" event will be fired, indicating to the publisher that it is\n   * safe to delete this queue.\n   *\n   * @fires OrderedQueue#drain\n   */\n  async publish() {\n    // If there's nothing to flush, don't try, just short-circuit to the drain event.\n    // This can happen if we get a publish() call after already being drained, in\n    // the case that topic.flush() pulls a reference to us before we get deleted.\n    if (!this.batches.length) {\n      this.emit('drain');\n      return;\n    }\n    this.inFlight = true;\n    if (this.pending) {\n      clearTimeout(this.pending);\n      delete this.pending;\n    }\n    const {\n      messages,\n      callbacks\n    } = this.batches.pop();\n    try {\n      await this._publish(messages, callbacks);\n    } catch (e) {\n      const err = e;\n      this.inFlight = false;\n      this.handlePublishFailure(err);\n    } finally {\n      this.inFlight = false;\n    }\n    if (this.batches.length) {\n      this.beginNextPublish();\n    } else {\n      this.emit('drain');\n    }\n  }\n  /**\n   * For ordered queues, this does exactly the same thing as `publish()`.\n   *\n   * @fires OrderedQueue#drain\n   */\n  async publishDrain() {\n    await this.publish();\n  }\n  /**\n   * Tells the queue it is ok to continue publishing messages.\n   */\n  resumePublishing() {\n    delete this.error;\n    // once this is called, we'll make this object eligible for garbage\n    // collection. by wrapping in nextTick() we'll give users an opportunity\n    // to use it again instead of deleting instantly and then creating a new\n    // instance.\n    process.nextTick(() => {\n      if (!this.batches.length) {\n        this.emit('drain');\n      }\n    });\n  }\n}\nexports.OrderedQueue = OrderedQueue;","map":{"version":3,"names":["events_1","require","message_batch_1","publish_error_1","util_1","MessageQueue","EventEmitter","constructor","publisher","batchOptions","settings","batching","updateOptions","_publish","messages","callbacks","topic","reqOpts","name","length","requestCallback","request","promisify","bind","resp","client","method","gaxOpts","messageIds","forEach","callback","i","e","err","exports","Queue","batch","MessageBatch","setOptions","add","message","canFit","publish","catch","isFull","pending","maxMilliseconds","setTimeout","publishDrain","_publishInternal","fullyDrain","clearTimeout","emit","OrderedQueue","key","batches","inFlight","b","currentBatch","push","createBatch","error","isAtMax","unshift","beginNextPublish","timeWaiting","Date","now","created","delay","Math","max","handlePublishFailure","PublishError","pop","resumePublishing","process","nextTick"],"sources":["../../../src/publisher/message-queues.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}