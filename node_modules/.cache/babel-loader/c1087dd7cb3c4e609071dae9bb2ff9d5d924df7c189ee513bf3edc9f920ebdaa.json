{"ast":null,"code":"\"use strict\";\n\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ModAckQueue = exports.AckQueue = exports.MessageQueue = exports.BatchError = void 0;\nconst google_gax_1 = require(\"google-gax\");\nconst defer = require(\"p-defer\");\nconst ack_metadata_1 = require(\"./ack-metadata\");\nconst exponential_retry_1 = require(\"./exponential-retry\");\nconst subscriber_1 = require(\"./subscriber\");\nconst temporal_1 = require(\"./temporal\");\nconst util_1 = require(\"./util\");\nconst debug_1 = require(\"./debug\");\n/**\n * Error class used to signal a batch failure.\n *\n * Now that we have exactly-once delivery subscriptions, we'll only\n * throw one of these if there was an unknown error.\n *\n * @class\n *\n * @param {string} message The error message.\n * @param {GoogleError} err The grpc error.\n */\nclass BatchError extends debug_1.DebugMessage {\n  constructor(err, ackIds, rpc) {\n    super(`Failed to \"${rpc}\" for ${ackIds.length} message(s). Reason: ${process.env.DEBUG_GRPC ? err.stack : err.message}`, err);\n    this.ackIds = ackIds;\n    this.code = err.code;\n    this.details = err.message;\n  }\n}\nexports.BatchError = BatchError;\n/**\n * @typedef {object} BatchOptions\n * @property {object} [callOptions] Request configuration option, outlined\n *     here: {@link https://googleapis.github.io/gax-nodejs/interfaces/CallOptions.html}.\n * @property {number} [maxMessages=3000] Maximum number of messages allowed in\n *     each batch sent.\n * @property {number} [maxMilliseconds=100] Maximum duration to wait before\n *     sending a batch. Batches can be sent earlier if the maxMessages option\n *     is met before the configured duration has passed.\n */\n/**\n * Class for buffering ack/modAck requests.\n *\n * @private\n * @class\n *\n * @param {Subscriber} sub The subscriber we're queueing requests for.\n * @param {BatchOptions} options Batching options.\n */\nclass MessageQueue {\n  constructor(sub, options = {}) {\n    this._closed = false;\n    this.numPendingRequests = 0;\n    this.numInFlightRequests = 0;\n    this.numInRetryRequests = 0;\n    this._requests = [];\n    this._subscriber = sub;\n    this._retrier = new exponential_retry_1.ExponentialRetry(temporal_1.Duration.from({\n      seconds: 1\n    }), temporal_1.Duration.from({\n      seconds: 64\n    }));\n    this.setOptions(options);\n  }\n  /**\n   * Shuts down this message queue gracefully. Any acks/modAcks pending in\n   * the queue or waiting for retry will be removed. If exactly-once delivery\n   * is enabled on the subscription, we'll send permanent failures to\n   * anyone waiting on completions; otherwise we'll send successes.\n   *\n   * If a flush is desired first, do it before calling close().\n   *\n   * @private\n   */\n  close() {\n    let requests = this._requests;\n    this._requests = [];\n    this.numInFlightRequests = this.numPendingRequests = 0;\n    requests = requests.concat(this._retrier.close());\n    const isExactlyOnceDelivery = this._subscriber.isExactlyOnceDelivery;\n    requests.forEach(r => {\n      if (r.responsePromise) {\n        if (isExactlyOnceDelivery) {\n          r.responsePromise.reject(new subscriber_1.AckError(subscriber_1.AckResponses.Invalid, 'Subscriber closed'));\n        } else {\n          r.responsePromise.resolve();\n        }\n      }\n    });\n    this._closed = true;\n  }\n  /**\n   * Gets the default buffer time in ms.\n   *\n   * @returns {number}\n   * @private\n   */\n  get maxMilliseconds() {\n    return this._options.maxMilliseconds;\n  }\n  /**\n   * Adds a message to the queue.\n   *\n   * @param {Message} message The message to add.\n   * @param {number} [deadline] The deadline.\n   * @private\n   */\n  add({\n    ackId\n  }, deadline) {\n    if (this._closed) {\n      if (this._subscriber.isExactlyOnceDelivery) {\n        throw new subscriber_1.AckError(subscriber_1.AckResponses.Invalid, 'Subscriber closed');\n      } else {\n        return Promise.resolve();\n      }\n    }\n    const {\n      maxMessages,\n      maxMilliseconds\n    } = this._options;\n    const responsePromise = defer();\n    this._requests.push({\n      ackId,\n      deadline,\n      responsePromise,\n      retryCount: 0\n    });\n    this.numPendingRequests++;\n    this.numInFlightRequests++;\n    if (this._requests.length >= maxMessages) {\n      this.flush();\n    } else if (!this._timer) {\n      this._timer = setTimeout(() => this.flush(), maxMilliseconds);\n    }\n    return responsePromise.promise;\n  }\n  /**\n   * Retry handler for acks/modacks that have transient failures. Unless\n   * it's passed the final deadline, we will just re-queue it for sending.\n   *\n   * @private\n   */\n  handleRetry(message, totalTime) {\n    var _a;\n    // Has it been too long?\n    if (totalTime.totalOf('minute') >= 10 || this.shouldFailEarly(message)) {\n      (_a = message.responsePromise) === null || _a === void 0 ? void 0 : _a.reject(new subscriber_1.AckError(subscriber_1.AckResponses.Invalid, 'Retried for too long'));\n      return;\n    }\n    // Just throw it in for another round of processing on the next batch.\n    this._requests.push(message);\n    this.numPendingRequests++;\n    this.numInFlightRequests++;\n    this.numInRetryRequests--;\n    // Make sure we actually do have another batch scheduled.\n    if (!this._timer) {\n      this._timer = setTimeout(() => this.flush(), this._options.maxMilliseconds);\n    }\n  }\n  /**\n   * This hook lets a subclass tell the retry handler to go ahead and fail early.\n   *\n   * @private\n   */\n  shouldFailEarly(message) {\n    message;\n    return false;\n  }\n  /**\n   * Sends a batch of messages.\n   * @private\n   */\n  async flush() {\n    if (this._timer) {\n      clearTimeout(this._timer);\n      delete this._timer;\n    }\n    const batch = this._requests;\n    const batchSize = batch.length;\n    const deferred = this._onFlush;\n    this._requests = [];\n    this.numPendingRequests -= batchSize;\n    delete this._onFlush;\n    try {\n      const toRetry = await this._sendBatch(batch);\n      // We'll get back anything that needs a retry for transient errors.\n      for (const m of toRetry) {\n        this.numInRetryRequests++;\n        m.retryCount++;\n        this._retrier.retryLater(m, this.handleRetry.bind(this));\n      }\n    } catch (e) {\n      // These queues are used for ack and modAck messages, which should\n      // never surface an error to the user level. However, we'll emit\n      // them onto this debug channel in case debug info is needed.\n      const err = e;\n      const debugMsg = new debug_1.DebugMessage(err.message, err);\n      this._subscriber.emit('debug', debugMsg);\n    }\n    this.numInFlightRequests -= batchSize;\n    if (deferred) {\n      deferred.resolve();\n    }\n    if (this.numInFlightRequests <= 0 && this.numInRetryRequests <= 0 && this._onDrain) {\n      this._onDrain.resolve();\n      delete this._onDrain;\n    }\n  }\n  /**\n   * Returns a promise that resolves after the next flush occurs.\n   *\n   * @returns {Promise}\n   * @private\n   */\n  onFlush() {\n    if (!this._onFlush) {\n      this._onFlush = defer();\n    }\n    return this._onFlush.promise;\n  }\n  /**\n   * Returns a promise that resolves when all in-flight messages have settled.\n   */\n  onDrain() {\n    if (!this._onDrain) {\n      this._onDrain = defer();\n    }\n    return this._onDrain.promise;\n  }\n  /**\n   * Set the batching options.\n   *\n   * @param {BatchOptions} options Batching options.\n   * @private\n   */\n  setOptions(options) {\n    const defaults = {\n      maxMessages: 3000,\n      maxMilliseconds: 100\n    };\n    this._options = Object.assign(defaults, options);\n  }\n  /**\n   * Succeed a whole batch of Acks/Modacks for an OK RPC response.\n   *\n   * @private\n   */\n  handleAckSuccesses(batch) {\n    // Everyone gets a resolve!\n    batch.forEach(({\n      responsePromise\n    }) => {\n      responsePromise === null || responsePromise === void 0 ? void 0 : responsePromise.resolve();\n    });\n  }\n  /**\n   * If we get an RPC failure of any kind, this will take care of deciding\n   * what to do for each related ack/modAck. Successful ones will have their\n   * Promises resolved, permanent errors will have their Promises rejected,\n   * and transients will be returned for retry.\n   *\n   * Note that this is only used for subscriptions with exactly-once\n   * delivery enabled, so _sendBatch() in the classes below take care of\n   * resolving errors to success; they don't make it here.\n   *\n   * @private\n   */\n  handleAckFailures(operation, batch, rpcError) {\n    const toSucceed = [];\n    const toRetry = [];\n    const toError = new Map([[subscriber_1.AckResponses.PermissionDenied, []], [subscriber_1.AckResponses.FailedPrecondition, []], [subscriber_1.AckResponses.Other, []]]);\n    // Parse any error codes, both for the RPC call and the ErrorInfo.\n    const error = rpcError.code ? (0, ack_metadata_1.processAckRpcError)(rpcError.code) : undefined;\n    const codes = (0, ack_metadata_1.processAckErrorInfo)(rpcError);\n    for (const m of batch) {\n      if (codes.has(m.ackId)) {\n        // This ack has an ErrorInfo entry, so use that to route it.\n        const code = codes.get(m.ackId);\n        if (code.transient) {\n          // Transient errors get retried.\n          toRetry.push(m);\n        } else {\n          // It's a permanent error.\n          (0, util_1.addToBucket)(toError, code.response, m);\n        }\n      } else if (error !== undefined) {\n        // This ack doesn't have an ErrorInfo entry, but we do have an RPC\n        // error, so use that to route it.\n        if (error.transient) {\n          toRetry.push(m);\n        } else {\n          (0, util_1.addToBucket)(toError, error.response, m);\n        }\n      } else {\n        // Looks like this one worked out.\n        toSucceed.push(m);\n      }\n    }\n    // To remain consistent with previous behaviour, we will push a debug\n    // stream message if an unknown error happens during ack.\n    const others = toError.get(subscriber_1.AckResponses.Other);\n    if (others === null || others === void 0 ? void 0 : others.length) {\n      const otherIds = others.map(e => e.ackId);\n      const debugMsg = new BatchError(rpcError, otherIds, operation);\n      this._subscriber.emit('debug', debugMsg);\n    }\n    // Take care of following up on all the Promises.\n    toSucceed.forEach(m => {\n      var _a;\n      (_a = m.responsePromise) === null || _a === void 0 ? void 0 : _a.resolve();\n    });\n    for (const e of toError.entries()) {\n      e[1].forEach(m => {\n        var _a;\n        const exc = new subscriber_1.AckError(e[0], rpcError.message);\n        (_a = m.responsePromise) === null || _a === void 0 ? void 0 : _a.reject(exc);\n      });\n    }\n    return {\n      toError,\n      toRetry\n    };\n  }\n  /**\n   * Since we handle our own retries for ack/modAck calls when exactly-once\n   * delivery is enabled on a subscription, we conditionally need to disable\n   * the gax retries. This returns an appropriate CallOptions for the\n   * subclasses to pass down.\n   *\n   * @private\n   */\n  getCallOptions() {\n    let callOptions = this._options.callOptions;\n    if (this._subscriber.isExactlyOnceDelivery) {\n      // If exactly-once-delivery is enabled, tell gax not to do retries for us.\n      callOptions = Object.assign({}, callOptions !== null && callOptions !== void 0 ? callOptions : {});\n      callOptions.retry = new google_gax_1.RetryOptions([], {\n        initialRetryDelayMillis: 0,\n        retryDelayMultiplier: 0,\n        maxRetryDelayMillis: 0\n      });\n    }\n    return callOptions;\n  }\n}\nexports.MessageQueue = MessageQueue;\n/**\n * Queues up Acknowledge (ack) requests.\n *\n * @private\n * @class\n */\nclass AckQueue extends MessageQueue {\n  /**\n   * Sends a batch of ack requests.\n   *\n   * @private\n   *\n   * @param {Array.<Array.<string|number>>} batch Array of ackIds and deadlines.\n   * @return {Promise}\n   */\n  async _sendBatch(batch) {\n    const client = await this._subscriber.getClient();\n    const ackIds = batch.map(({\n      ackId\n    }) => ackId);\n    const reqOpts = {\n      subscription: this._subscriber.name,\n      ackIds\n    };\n    try {\n      await client.acknowledge(reqOpts, this.getCallOptions());\n      // It's okay if these pass through since they're successful anyway.\n      this.handleAckSuccesses(batch);\n      return [];\n    } catch (e) {\n      // If exactly-once delivery isn't enabled, don't do error processing. We'll\n      // emulate previous behaviour by resolving all pending Promises with\n      // a success status, and then throwing a BatchError for debug logging.\n      if (!this._subscriber.isExactlyOnceDelivery) {\n        batch.forEach(m => {\n          var _a;\n          (_a = m.responsePromise) === null || _a === void 0 ? void 0 : _a.resolve();\n        });\n        throw new BatchError(e, ackIds, 'ack');\n      } else {\n        const grpcError = e;\n        try {\n          const results = this.handleAckFailures('ack', batch, grpcError);\n          return results.toRetry;\n        } catch (e) {\n          // This should only ever happen if there's a code failure.\n          const err = e;\n          this._subscriber.emit('debug', new debug_1.DebugMessage(err.message, err));\n          const exc = new subscriber_1.AckError(subscriber_1.AckResponses.Other, 'Code error');\n          batch.forEach(m => {\n            var _a;\n            (_a = m.responsePromise) === null || _a === void 0 ? void 0 : _a.reject(exc);\n          });\n          return [];\n        }\n      }\n    }\n  }\n}\nexports.AckQueue = AckQueue;\n/**\n * Queues up ModifyAckDeadline requests and sends them out in batches.\n *\n * @private\n * @class\n */\nclass ModAckQueue extends MessageQueue {\n  /**\n   * Sends a batch of modAck requests. Each deadline requires its own request,\n   * so we have to group all the ackIds by deadline and send multiple requests.\n   *\n   * @private\n   *\n   * @param {Array.<Array.<string|number>>} batch Array of ackIds and deadlines.\n   * @return {Promise}\n   */\n  async _sendBatch(batch) {\n    const client = await this._subscriber.getClient();\n    const subscription = this._subscriber.name;\n    const modAckTable = batch.reduce((table, message) => {\n      if (!table[message.deadline]) {\n        table[message.deadline] = [];\n      }\n      table[message.deadline].push(message);\n      return table;\n    }, {});\n    const callOptions = this.getCallOptions();\n    const modAckRequests = Object.keys(modAckTable).map(async deadline => {\n      const messages = modAckTable[deadline];\n      const ackIds = messages.map(m => m.ackId);\n      const ackDeadlineSeconds = Number(deadline);\n      const reqOpts = {\n        subscription,\n        ackIds,\n        ackDeadlineSeconds\n      };\n      try {\n        await client.modifyAckDeadline(reqOpts, callOptions);\n        // It's okay if these pass through since they're successful anyway.\n        this.handleAckSuccesses(messages);\n        return [];\n      } catch (e) {\n        // If exactly-once delivery isn't enabled, don't do error processing. We'll\n        // emulate previous behaviour by resolving all pending Promises with\n        // a success status, and then throwing a BatchError for debug logging.\n        if (!this._subscriber.isExactlyOnceDelivery) {\n          batch.forEach(m => {\n            var _a;\n            (_a = m.responsePromise) === null || _a === void 0 ? void 0 : _a.resolve();\n          });\n          throw new BatchError(e, ackIds, 'modAck');\n        } else {\n          const grpcError = e;\n          const newBatch = this.handleAckFailures('modAck', messages, grpcError);\n          return newBatch.toRetry;\n        }\n      }\n    });\n    // This catches the sub-failures and bubbles up anything we need to bubble.\n    const allNewBatches = await Promise.all(modAckRequests);\n    return allNewBatches.reduce((p, c) => [...(p !== null && p !== void 0 ? p : []), ...c]);\n  }\n  // For modacks only, we'll stop retrying after 3 tries.\n  shouldFailEarly(message) {\n    return message.retryCount >= 3;\n  }\n}\nexports.ModAckQueue = ModAckQueue;","map":{"version":3,"names":["google_gax_1","require","defer","ack_metadata_1","exponential_retry_1","subscriber_1","temporal_1","util_1","debug_1","BatchError","DebugMessage","constructor","err","ackIds","rpc","length","process","env","DEBUG_GRPC","stack","message","code","details","exports","MessageQueue","sub","options","_closed","numPendingRequests","numInFlightRequests","numInRetryRequests","_requests","_subscriber","_retrier","ExponentialRetry","Duration","from","seconds","setOptions","close","requests","concat","isExactlyOnceDelivery","forEach","r","responsePromise","reject","AckError","AckResponses","Invalid","resolve","maxMilliseconds","_options","add","ackId","deadline","Promise","maxMessages","push","retryCount","flush","_timer","setTimeout","promise","handleRetry","totalTime","totalOf","shouldFailEarly","_a","clearTimeout","batch","batchSize","deferred","_onFlush","toRetry","_sendBatch","m","retryLater","bind","e","debugMsg","emit","_onDrain","onFlush","onDrain","defaults","Object","assign","handleAckSuccesses","handleAckFailures","operation","rpcError","toSucceed","toError","Map","PermissionDenied","FailedPrecondition","Other","error","processAckRpcError","undefined","codes","processAckErrorInfo","has","get","transient","addToBucket","response","others","otherIds","map","entries","exc","getCallOptions","callOptions","retry","RetryOptions","initialRetryDelayMillis","retryDelayMultiplier","maxRetryDelayMillis","AckQueue","client","getClient","reqOpts","subscription","name","acknowledge","grpcError","results","ModAckQueue","modAckTable","reduce","table","modAckRequests","keys","messages","ackDeadlineSeconds","Number","modifyAckDeadline","newBatch","allNewBatches","all","p","c"],"sources":["../../src/message-queues.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}