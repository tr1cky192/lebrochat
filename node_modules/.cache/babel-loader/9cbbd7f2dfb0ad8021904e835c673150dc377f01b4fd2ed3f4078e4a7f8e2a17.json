{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { validateKey, validateValue } from './tracestate-validators';\nvar MAX_TRACE_STATE_ITEMS = 32;\nvar MAX_TRACE_STATE_LEN = 512;\nvar LIST_MEMBERS_SEPARATOR = ',';\nvar LIST_MEMBER_KEY_VALUE_SPLITTER = '=';\n/**\n * TraceState must be a class and not a simple object type because of the spec\n * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).\n *\n * Here is the list of allowed mutations:\n * - New key-value pair should be added into the beginning of the list\n * - The value of any key can be updated. Modified keys MUST be moved to the\n * beginning of the list.\n */\nvar TraceStateImpl = /** @class */function () {\n  function TraceStateImpl(rawTraceState) {\n    this._internalState = new Map();\n    if (rawTraceState) this._parse(rawTraceState);\n  }\n  TraceStateImpl.prototype.set = function (key, value) {\n    // TODO: Benchmark the different approaches(map vs list) and\n    // use the faster one.\n    var traceState = this._clone();\n    if (traceState._internalState.has(key)) {\n      traceState._internalState.delete(key);\n    }\n    traceState._internalState.set(key, value);\n    return traceState;\n  };\n  TraceStateImpl.prototype.unset = function (key) {\n    var traceState = this._clone();\n    traceState._internalState.delete(key);\n    return traceState;\n  };\n  TraceStateImpl.prototype.get = function (key) {\n    return this._internalState.get(key);\n  };\n  TraceStateImpl.prototype.serialize = function () {\n    var _this = this;\n    return this._keys().reduce(function (agg, key) {\n      agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));\n      return agg;\n    }, []).join(LIST_MEMBERS_SEPARATOR);\n  };\n  TraceStateImpl.prototype._parse = function (rawTraceState) {\n    if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;\n    this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning\n    .reduce(function (agg, part) {\n      var listMember = part.trim(); // Optional Whitespace (OWS) handling\n      var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);\n      if (i !== -1) {\n        var key = listMember.slice(0, i);\n        var value = listMember.slice(i + 1, part.length);\n        if (validateKey(key) && validateValue(value)) {\n          agg.set(key, value);\n        } else {\n          // TODO: Consider to add warning log\n        }\n      }\n      return agg;\n    }, new Map());\n    // Because of the reverse() requirement, trunc must be done after map is created\n    if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {\n      this._internalState = new Map(Array.from(this._internalState.entries()).reverse() // Use reverse same as original tracestate parse chain\n      .slice(0, MAX_TRACE_STATE_ITEMS));\n    }\n  };\n  TraceStateImpl.prototype._keys = function () {\n    return Array.from(this._internalState.keys()).reverse();\n  };\n  TraceStateImpl.prototype._clone = function () {\n    var traceState = new TraceStateImpl();\n    traceState._internalState = new Map(this._internalState);\n    return traceState;\n  };\n  return TraceStateImpl;\n}();\nexport { TraceStateImpl };","map":{"version":3,"names":["validateKey","validateValue","MAX_TRACE_STATE_ITEMS","MAX_TRACE_STATE_LEN","LIST_MEMBERS_SEPARATOR","LIST_MEMBER_KEY_VALUE_SPLITTER","TraceStateImpl","rawTraceState","_internalState","Map","_parse","prototype","set","key","value","traceState","_clone","has","delete","unset","get","serialize","_this","_keys","reduce","agg","push","join","length","split","reverse","part","listMember","trim","i","indexOf","slice","size","Array","from","entries","keys"],"sources":["C:\\Users\\Ігор\\clone\\node_modules\\@opentelemetry\\api\\src\\trace\\internal\\tracestate-impl.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TraceState } from '../trace_state';\nimport { validateKey, validateValue } from './tracestate-validators';\n\nconst MAX_TRACE_STATE_ITEMS = 32;\nconst MAX_TRACE_STATE_LEN = 512;\nconst LIST_MEMBERS_SEPARATOR = ',';\nconst LIST_MEMBER_KEY_VALUE_SPLITTER = '=';\n\n/**\n * TraceState must be a class and not a simple object type because of the spec\n * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).\n *\n * Here is the list of allowed mutations:\n * - New key-value pair should be added into the beginning of the list\n * - The value of any key can be updated. Modified keys MUST be moved to the\n * beginning of the list.\n */\nexport class TraceStateImpl implements TraceState {\n  private _internalState: Map<string, string> = new Map();\n\n  constructor(rawTraceState?: string) {\n    if (rawTraceState) this._parse(rawTraceState);\n  }\n\n  set(key: string, value: string): TraceStateImpl {\n    // TODO: Benchmark the different approaches(map vs list) and\n    // use the faster one.\n    const traceState = this._clone();\n    if (traceState._internalState.has(key)) {\n      traceState._internalState.delete(key);\n    }\n    traceState._internalState.set(key, value);\n    return traceState;\n  }\n\n  unset(key: string): TraceStateImpl {\n    const traceState = this._clone();\n    traceState._internalState.delete(key);\n    return traceState;\n  }\n\n  get(key: string): string | undefined {\n    return this._internalState.get(key);\n  }\n\n  serialize(): string {\n    return this._keys()\n      .reduce((agg: string[], key) => {\n        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));\n        return agg;\n      }, [])\n      .join(LIST_MEMBERS_SEPARATOR);\n  }\n\n  private _parse(rawTraceState: string) {\n    if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;\n    this._internalState = rawTraceState\n      .split(LIST_MEMBERS_SEPARATOR)\n      .reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning\n      .reduce((agg: Map<string, string>, part: string) => {\n        const listMember = part.trim(); // Optional Whitespace (OWS) handling\n        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);\n        if (i !== -1) {\n          const key = listMember.slice(0, i);\n          const value = listMember.slice(i + 1, part.length);\n          if (validateKey(key) && validateValue(value)) {\n            agg.set(key, value);\n          } else {\n            // TODO: Consider to add warning log\n          }\n        }\n        return agg;\n      }, new Map());\n\n    // Because of the reverse() requirement, trunc must be done after map is created\n    if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {\n      this._internalState = new Map(\n        Array.from(this._internalState.entries())\n          .reverse() // Use reverse same as original tracestate parse chain\n          .slice(0, MAX_TRACE_STATE_ITEMS)\n      );\n    }\n  }\n\n  private _keys(): string[] {\n    return Array.from(this._internalState.keys()).reverse();\n  }\n\n  private _clone(): TraceStateImpl {\n    const traceState = new TraceStateImpl();\n    traceState._internalState = new Map(this._internalState);\n    return traceState;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}